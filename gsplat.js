class F{constructor(F=0,U=0,l=0){this.x=F,this.y=U,this.z=l}equals(F){return this.x===F.x&&(this.y===F.y&&this.z===F.z)}add(U){return"number"==typeof U?new F(this.x+U,this.y+U,this.z+U):new F(this.x+U.x,this.y+U.y,this.z+U.z)}subtract(U){return"number"==typeof U?new F(this.x-U,this.y-U,this.z-U):new F(this.x-U.x,this.y-U.y,this.z-U.z)}multiply(U){return"number"==typeof U?new F(this.x*U,this.y*U,this.z*U):new F(this.x*U.x,this.y*U.y,this.z*U.z)}lerp(U,l){return new F(this.x+(U.x-this.x)*l,this.y+(U.y-this.y)*l,this.z+(U.z-this.z)*l)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}distanceTo(F){return Math.sqrt((this.x-F.x)**2+(this.y-F.y)**2+(this.z-F.z)**2)}normalize(){const U=this.length();return new F(this.x/U,this.y/U,this.z/U)}flat(){return[this.x,this.y,this.z]}clone(){return new F(this.x,this.y,this.z)}}class U{constructor(F=0,U=0,l=0,t=1){this.x=F,this.y=U,this.z=l,this.w=t}equals(F){return this.x===F.x&&(this.y===F.y&&(this.z===F.z&&this.w===F.w))}normalize(){const F=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return new U(this.x/F,this.y/F,this.z/F,this.w/F)}multiply(F){const l=this.w,t=this.x,V=this.y,Z=this.z,d=F.w,Q=F.x,n=F.y,R=F.z;return new U(l*Q+t*d+V*R-Z*n,l*n-t*R+V*d+Z*Q,l*R+t*n-V*Q+Z*d,l*d-t*Q-V*n-Z*R)}flat(){return[this.x,this.y,this.z,this.w]}clone(){return new U(this.x,this.y,this.z,this.w)}static FromEuler(F){const l=F.x/2,t=F.y/2,V=F.z/2,Z=Math.cos(t),d=Math.sin(t),Q=Math.cos(l),n=Math.sin(l),R=Math.cos(V),W=Math.sin(V);return new U(Z*n*R+d*Q*W,d*Q*R-Z*n*W,Z*Q*W-d*n*R,Z*Q*R+d*n*W)}toEuler(){const U=2*(this.w*this.x+this.y*this.z),l=1-2*(this.x*this.x+this.y*this.y),t=Math.atan2(U,l);let V;const Z=2*(this.w*this.y-this.z*this.x);V=Math.abs(Z)>=1?Math.sign(Z)*Math.PI/2:Math.asin(Z);const d=2*(this.w*this.z+this.x*this.y),Q=1-2*(this.y*this.y+this.z*this.z),n=Math.atan2(d,Q);return new F(t,V,n)}static FromMatrix3(F){const l=F.buffer,t=l[0]+l[4]+l[8];let V,Z,d,Q;if(t>0){const F=.5/Math.sqrt(t+1);Q=.25/F,V=(l[7]-l[5])*F,Z=(l[2]-l[6])*F,d=(l[3]-l[1])*F}else if(l[0]>l[4]&&l[0]>l[8]){const F=2*Math.sqrt(1+l[0]-l[4]-l[8]);Q=(l[7]-l[5])/F,V=.25*F,Z=(l[1]+l[3])/F,d=(l[2]+l[6])/F}else if(l[4]>l[8]){const F=2*Math.sqrt(1+l[4]-l[0]-l[8]);Q=(l[2]-l[6])/F,V=(l[1]+l[3])/F,Z=.25*F,d=(l[5]+l[7])/F}else{const F=2*Math.sqrt(1+l[8]-l[0]-l[4]);Q=(l[3]-l[1])/F,V=(l[2]+l[6])/F,Z=(l[5]+l[7])/F,d=.25*F}return new U(V,Z,d,Q)}}class l{constructor(){const F=new Map;this.addEventListener=(U,l)=>{F.has(U)||F.set(U,new Set),F.get(U).add(l)},this.removeEventListener=(U,l)=>{F.has(U)&&F.get(U).delete(l)},this.hasEventListener=(U,l)=>!!F.has(U)&&F.get(U).has(l),this.dispatchEvent=U=>{if(F.has(U.type))for(const l of F.get(U.type))l(U)}}}class t extends l{constructor(){super(),this._position=new F,this._rotation=new U,this._changeEvent={type:"change"}}get position(){return this._position}set position(F){this._position.equals(F)||(this._position=F,this.dispatchEvent(this._changeEvent))}get rotation(){return this._rotation}set rotation(F){this._rotation.equals(F)||(this._rotation=F,this.dispatchEvent(this._changeEvent))}}class V{constructor(F=1,U=0,l=0,t=0,V=1,Z=0,d=0,Q=0,n=1){this.buffer=[F,U,l,t,V,Z,d,Q,n]}equals(F){if(this.buffer.length!==F.buffer.length)return!1;if(this.buffer===F.buffer)return!0;for(let U=0;U<this.buffer.length;U++)if(this.buffer[U]!==F.buffer[U])return!1;return!0}multiply(F){const U=this.buffer,l=F.buffer;return new V(l[0]*U[0]+l[3]*U[1]+l[6]*U[2],l[1]*U[0]+l[4]*U[1]+l[7]*U[2],l[2]*U[0]+l[5]*U[1]+l[8]*U[2],l[0]*U[3]+l[3]*U[4]+l[6]*U[5],l[1]*U[3]+l[4]*U[4]+l[7]*U[5],l[2]*U[3]+l[5]*U[4]+l[8]*U[5],l[0]*U[6]+l[3]*U[7]+l[6]*U[8],l[1]*U[6]+l[4]*U[7]+l[7]*U[8],l[2]*U[6]+l[5]*U[7]+l[8]*U[8])}clone(){const F=this.buffer;return new V(F[0],F[1],F[2],F[3],F[4],F[5],F[6],F[7],F[8])}static Eye(F=1){return new V(F,0,0,0,F,0,0,0,F)}static Diagonal(F){return new V(F.x,0,0,0,F.y,0,0,0,F.z)}static RotationFromQuaternion(F){return new V(1-2*F.y*F.y-2*F.z*F.z,2*F.x*F.y-2*F.z*F.w,2*F.x*F.z+2*F.y*F.w,2*F.x*F.y+2*F.z*F.w,1-2*F.x*F.x-2*F.z*F.z,2*F.y*F.z-2*F.x*F.w,2*F.x*F.z-2*F.y*F.w,2*F.y*F.z+2*F.x*F.w,1-2*F.x*F.x-2*F.y*F.y)}static RotationFromEuler(F){const U=Math.cos(F.x),l=Math.sin(F.x),t=Math.cos(F.y),Z=Math.sin(F.y),d=Math.cos(F.z),Q=Math.sin(F.z);return new V(...[t*d+Z*l*Q,-t*Q+Z*l*d,Z*U,U*Q,U*d,-l,-Z*d+t*l*Q,Z*Q+t*l*d,t*U])}}class Z{constructor(F=1,U=0,l=0,t=0,V=0,Z=1,d=0,Q=0,n=0,R=0,W=1,e=0,a=0,B=0,i=0,h=1){this.buffer=[F,U,l,t,V,Z,d,Q,n,R,W,e,a,B,i,h]}equals(F){if(this.buffer.length!==F.buffer.length)return!1;if(this.buffer===F.buffer)return!0;for(let U=0;U<this.buffer.length;U++)if(this.buffer[U]!==F.buffer[U])return!1;return!0}multiply(F){const U=this.buffer,l=F.buffer;return new Z(l[0]*U[0]+l[1]*U[4]+l[2]*U[8]+l[3]*U[12],l[0]*U[1]+l[1]*U[5]+l[2]*U[9]+l[3]*U[13],l[0]*U[2]+l[1]*U[6]+l[2]*U[10]+l[3]*U[14],l[0]*U[3]+l[1]*U[7]+l[2]*U[11]+l[3]*U[15],l[4]*U[0]+l[5]*U[4]+l[6]*U[8]+l[7]*U[12],l[4]*U[1]+l[5]*U[5]+l[6]*U[9]+l[7]*U[13],l[4]*U[2]+l[5]*U[6]+l[6]*U[10]+l[7]*U[14],l[4]*U[3]+l[5]*U[7]+l[6]*U[11]+l[7]*U[15],l[8]*U[0]+l[9]*U[4]+l[10]*U[8]+l[11]*U[12],l[8]*U[1]+l[9]*U[5]+l[10]*U[9]+l[11]*U[13],l[8]*U[2]+l[9]*U[6]+l[10]*U[10]+l[11]*U[14],l[8]*U[3]+l[9]*U[7]+l[10]*U[11]+l[11]*U[15],l[12]*U[0]+l[13]*U[4]+l[14]*U[8]+l[15]*U[12],l[12]*U[1]+l[13]*U[5]+l[14]*U[9]+l[15]*U[13],l[12]*U[2]+l[13]*U[6]+l[14]*U[10]+l[15]*U[14],l[12]*U[3]+l[13]*U[7]+l[14]*U[11]+l[15]*U[15])}clone(){const F=this.buffer;return new Z(F[0],F[1],F[2],F[3],F[4],F[5],F[6],F[7],F[8],F[9],F[10],F[11],F[12],F[13],F[14],F[15])}}class d extends t{constructor(l=new F(0,0,-5),t=new U,d=1132,Q=1132,n=.1,R=100){super();const W=()=>{const F=V.RotationFromQuaternion(this.rotation).buffer,U=this.position.flat(),l=[[F[0],F[1],F[2],0],[F[3],F[4],F[5],0],[F[6],F[7],F[8],0],[-U[0]*F[0]-U[1]*F[3]-U[2]*F[6],-U[0]*F[1]-U[1]*F[4]-U[2]*F[7],-U[0]*F[2]-U[1]*F[5]-U[2]*F[8],1]].flat();return new Z(...l)};this.position=l,this.rotation=t,this.fx=d,this.fy=Q,this.near=n,this.far=R,this.projectionMatrix=new Z,this.viewMatrix=new Z,this.viewProj=new Z,this.update=(F,U)=>{this.projectionMatrix=new Z(2*this.fx/F,0,0,0,0,-2*this.fy/U,0,0,0,0,this.far/(this.far-this.near),1,0,0,-this.far*this.near/(this.far-this.near),0),this.viewMatrix=W(),this.viewProj=this.projectionMatrix.multiply(this.viewMatrix)}}}class Q extends l{constructor(){super();const l=new Float32Array(1),t=new Int32Array(l.buffer),Z=F=>{l[0]=F;const U=t[0],V=U>>23&255;let Z,d=8388607&U;return 0==V?Z=0:V<113?(Z=0,d|=8388608,d>>=113-V,16777216&d&&(Z=1,d=0)):V<142?Z=V-112:(Z=31,d=0),(U>>31&1)<<15|Z<<10|d>>13},d=(F,U)=>(Z(F)|Z(U)<<16)>>>0,n={type:"change"};this._data=new Uint32Array(0),this._vertexCount=0,this._width=2048,this._height=0,this._positions=new Float32Array(0),this._rotations=new Float32Array(0),this._scales=new Float32Array(0),this.setData=l=>{this._vertexCount=l.length/Q.RowLength,this._height=Math.ceil(2*this._vertexCount/this._width),this._data=new Uint32Array(this._width*this._height*4),this._positions=new Float32Array(3*this._vertexCount),this._rotations=new Float32Array(4*this._vertexCount),this._scales=new Float32Array(3*this._vertexCount);const t=new Float32Array(l.buffer),Z=new Uint8Array(l.buffer),R=new Uint8Array(this._data.buffer),W=new Float32Array(this._data.buffer);for(let l=0;l<this._vertexCount;l++){this._positions[3*l+0]=t[8*l+0],this._positions[3*l+1]=t[8*l+1],this._positions[3*l+2]=t[8*l+2],this._rotations[4*l+0]=(Z[32*l+28+0]-128)/128,this._rotations[4*l+1]=(Z[32*l+28+1]-128)/128,this._rotations[4*l+2]=(Z[32*l+28+2]-128)/128,this._rotations[4*l+3]=(Z[32*l+28+3]-128)/128,this._scales[3*l+0]=t[8*l+3+0],this._scales[3*l+1]=t[8*l+3+1],this._scales[3*l+2]=t[8*l+3+2],W[8*l+0]=this._positions[3*l+0],W[8*l+1]=this._positions[3*l+1],W[8*l+2]=this._positions[3*l+2],R[4*(8*l+7)+0]=Z[32*l+24+0],R[4*(8*l+7)+1]=Z[32*l+24+1],R[4*(8*l+7)+2]=Z[32*l+24+2],R[4*(8*l+7)+3]=Z[32*l+24+3];const Q=V.RotationFromQuaternion(new U(this._rotations[4*l+1],this._rotations[4*l+2],this._rotations[4*l+3],-this._rotations[4*l+0])),n=V.Diagonal(new F(this._scales[3*l+0],this._scales[3*l+1],this._scales[3*l+2])).multiply(Q).buffer,e=[n[0]*n[0]+n[3]*n[3]+n[6]*n[6],n[0]*n[1]+n[3]*n[4]+n[6]*n[7],n[0]*n[2]+n[3]*n[5]+n[6]*n[8],n[1]*n[1]+n[4]*n[4]+n[7]*n[7],n[1]*n[2]+n[4]*n[5]+n[7]*n[8],n[2]*n[2]+n[5]*n[5]+n[8]*n[8]];this._data[8*l+4]=d(4*e[0],4*e[1]),this._data[8*l+5]=d(4*e[2],4*e[3]),this._data[8*l+6]=d(4*e[4],4*e[5])}this.dispatchEvent(n)},this.translate=F=>{const U=new Float32Array(this._data.buffer);for(let l=0;l<this._vertexCount;l++)this._positions[3*l+0]+=F.x,this._positions[3*l+1]+=F.y,this._positions[3*l+2]+=F.z,U[8*l+0]=this._positions[3*l+0],U[8*l+1]=this._positions[3*l+1],U[8*l+2]=this._positions[3*l+2];this.dispatchEvent(n)},this.rotate=l=>{const t=V.RotationFromQuaternion(l).buffer,Z=new Float32Array(this._data.buffer);for(let Q=0;Q<this._vertexCount;Q++){const n=this._positions[3*Q+0],R=this._positions[3*Q+1],W=this._positions[3*Q+2];this._positions[3*Q+0]=t[0]*n+t[1]*R+t[2]*W,this._positions[3*Q+1]=t[3]*n+t[4]*R+t[5]*W,this._positions[3*Q+2]=t[6]*n+t[7]*R+t[8]*W,Z[8*Q+0]=this._positions[3*Q+0],Z[8*Q+1]=this._positions[3*Q+1],Z[8*Q+2]=this._positions[3*Q+2];const e=new U(this._rotations[4*Q+1],this._rotations[4*Q+2],this._rotations[4*Q+3],this._rotations[4*Q+0]),a=l.multiply(e);this._rotations[4*Q+1]=a.x,this._rotations[4*Q+2]=a.y,this._rotations[4*Q+3]=a.z,this._rotations[4*Q+0]=a.w;const B=V.RotationFromQuaternion(new U(this._rotations[4*Q+1],this._rotations[4*Q+2],this._rotations[4*Q+3],-this._rotations[4*Q+0])),i=V.Diagonal(new F(this._scales[3*Q+0],this._scales[3*Q+1],this._scales[3*Q+2])).multiply(B).buffer,h=[i[0]*i[0]+i[3]*i[3]+i[6]*i[6],i[0]*i[1]+i[3]*i[4]+i[6]*i[7],i[0]*i[2]+i[3]*i[5]+i[6]*i[8],i[1]*i[1]+i[4]*i[4]+i[7]*i[7],i[1]*i[2]+i[4]*i[5]+i[7]*i[8],i[2]*i[2]+i[5]*i[5]+i[8]*i[8]];this._data[8*Q+4]=d(4*h[0],4*h[1]),this._data[8*Q+5]=d(4*h[2],4*h[3]),this._data[8*Q+6]=d(4*h[4],4*h[5])}this.dispatchEvent(n)},this.scale=l=>{const t=new Float32Array(this._data.buffer);for(let Z=0;Z<this.vertexCount;Z++){this._positions[3*Z+0]*=l.x,this._positions[3*Z+1]*=l.y,this._positions[3*Z+2]*=l.z,t[8*Z+0]=this._positions[3*Z+0],t[8*Z+1]=this._positions[3*Z+1],t[8*Z+2]=this._positions[3*Z+2],this._scales[3*Z+0]*=l.x,this._scales[3*Z+1]*=l.y,this._scales[3*Z+2]*=l.z;const Q=V.RotationFromQuaternion(new U(this._rotations[4*Z+1],this._rotations[4*Z+2],this._rotations[4*Z+3],-this._rotations[4*Z+0])),n=V.Diagonal(new F(this._scales[3*Z+0],this._scales[3*Z+1],this._scales[3*Z+2])).multiply(Q).buffer,R=[n[0]*n[0]+n[3]*n[3]+n[6]*n[6],n[0]*n[1]+n[3]*n[4]+n[6]*n[7],n[0]*n[2]+n[3]*n[5]+n[6]*n[8],n[1]*n[1]+n[4]*n[4]+n[7]*n[7],n[1]*n[2]+n[4]*n[5]+n[7]*n[8],n[2]*n[2]+n[5]*n[5]+n[8]*n[8]];this._data[8*Z+4]=d(4*R[0],4*R[1]),this._data[8*Z+5]=d(4*R[2],4*R[3]),this._data[8*Z+6]=d(4*R[4],4*R[5])}this.dispatchEvent(n)},this.limitBox=(F,U,l,t,V,Z)=>{if(F>=U)throw new Error(`xMin (${F}) must be smaller than xMax (${U})`);if(l>=t)throw new Error(`yMin (${l}) must be smaller than yMax (${t})`);if(V>=Z)throw new Error(`zMin (${V}) must be smaller than zMax (${Z})`);const d=new Uint8Array(this._vertexCount);for(let Q=0;Q<this._vertexCount;Q++){const n=this._positions[3*Q+0],R=this._positions[3*Q+1],W=this._positions[3*Q+2];n>=F&&n<=U&&R>=l&&R<=t&&W>=V&&W<=Z&&(d[Q]=1)}let Q=0;for(let F=0;F<this._vertexCount;F++)0!==d[F]&&(this._data[8*Q+0]=this._data[8*F+0],this._data[8*Q+1]=this._data[8*F+1],this._data[8*Q+2]=this._data[8*F+2],this._data[8*Q+3]=this._data[8*F+3],this._data[8*Q+4]=this._data[8*F+4],this._data[8*Q+5]=this._data[8*F+5],this._data[8*Q+6]=this._data[8*F+6],this._data[8*Q+7]=this._data[8*F+7],this._positions[3*Q+0]=this._positions[3*F+0],this._positions[3*Q+1]=this._positions[3*F+1],this._positions[3*Q+2]=this._positions[3*F+2],this._rotations[4*Q+0]=this._rotations[4*F+0],this._rotations[4*Q+1]=this._rotations[4*F+1],this._rotations[4*Q+2]=this._rotations[4*F+2],this._rotations[4*Q+3]=this._rotations[4*F+3],this._scales[3*Q+0]=this._scales[3*F+0],this._scales[3*Q+1]=this._scales[3*F+1],this._scales[3*Q+2]=this._scales[3*F+2],Q+=1);this._height=Math.ceil(2*Q/this._width),this._vertexCount=Q,this._data=new Uint32Array(this._data.buffer,0,this._width*this._height*4),this._positions=new Float32Array(this._positions.buffer,0,3*Q),this._rotations=new Float32Array(this._rotations.buffer,0,4*Q),this._scales=new Float32Array(this._scales.buffer,0,3*Q),this.dispatchEvent(n)},this.saveToFile=F=>{if(!document)return;const U=new Uint8Array(this._vertexCount*Q.RowLength),l=new Float32Array(U.buffer),t=new Uint8Array(U.buffer),V=new Uint8Array(this._data.buffer);for(let F=0;F<this._vertexCount;F++)l[8*F+0]=this._positions[3*F+0],l[8*F+1]=this._positions[3*F+1],l[8*F+2]=this._positions[3*F+2],t[32*F+24+0]=V[4*(8*F+7)+0],t[32*F+24+1]=V[4*(8*F+7)+1],t[32*F+24+2]=V[4*(8*F+7)+2],t[32*F+24+3]=V[4*(8*F+7)+3],l[8*F+3+0]=this._scales[3*F+0],l[8*F+3+1]=this._scales[3*F+1],l[8*F+3+2]=this._scales[3*F+2],t[32*F+28+0]=128*this._rotations[4*F+0]+128&255,t[32*F+28+1]=128*this._rotations[4*F+1]+128&255,t[32*F+28+2]=128*this._rotations[4*F+2]+128&255,t[32*F+28+3]=128*this._rotations[4*F+3]+128&255;const Z=new Blob([U.buffer],{type:"application/octet-stream"}),d=document.createElement("a");d.download=F,d.href=URL.createObjectURL(Z),d.click()}}get data(){return this._data}get vertexCount(){return this._vertexCount}get width(){return this._width}get height(){return this._height}get positions(){return this._positions}get rotations(){return this._rotations}get scales(){return this._scales}}Q.RowLength=32;class n{static async LoadAsync(F,U,l){const t=await fetch(F,{mode:"cors",credentials:"omit"});if(200!=t.status)throw new Error(t.status+" Unable to load "+t.url);const V=t.body.getReader(),Z=parseInt(t.headers.get("content-length")),d=new Uint8Array(Z);let Q=0;for(;;){const{done:F,value:U}=await V.read();if(F)break;d.set(U,Q),Q+=U.length,null==l||l(Q/Z)}U.setData(d)}static async LoadFromFileAsync(F,U,l){const t=new FileReader;t.onload=F=>{const l=new Uint8Array(F.target.result);U.setData(l)},t.onprogress=F=>{null==l||l(F.loaded/F.total)},t.readAsArrayBuffer(F),await new Promise((F=>{t.onloadend=()=>{F()}}))}}class R{static async LoadAsync(F,U,l,t=""){const V=await fetch(F,{mode:"cors",credentials:"omit"});if(200!=V.status)throw new Error(V.status+" Unable to load "+V.url);const Z=V.body.getReader(),d=parseInt(V.headers.get("content-length")),Q=new Uint8Array(d);let n=0;for(;;){const{done:F,value:U}=await Z.read();if(F)break;Q.set(U,n),n+=U.length,null==l||l(n/d)}if(112!==Q[0]||108!==Q[1]||121!==Q[2]||10!==Q[3])throw new Error("Invalid PLY file");const R=new Uint8Array(this._ParsePLYBuffer(Q.buffer,t));U.setData(R)}static async LoadFromFileAsync(F,U,l,t=""){const V=new FileReader;V.onload=F=>{const l=new Uint8Array(this._ParsePLYBuffer(F.target.result,t));U.setData(l)},V.onprogress=F=>{null==l||l(F.loaded/F.total)},V.readAsArrayBuffer(F),await new Promise((F=>{V.onloadend=()=>{F()}}))}static _ParsePLYBuffer(l,t){const V=new Uint8Array(l),Z=(new TextDecoder).decode(V.slice(0,10240)),d="end_header\n",n=Z.indexOf(d);if(n<0)throw new Error("Unable to read .ply file header");const R=parseInt(/element vertex (\d+)\n/.exec(Z)[1]);let W=0;const e={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1},a=[];for(const F of Z.slice(0,n).split("\n").filter((F=>F.startsWith("property ")))){const[U,l,t]=F.split(" ");if(a.push({name:t,type:l,offset:W}),!e[l])throw new Error(`Unsupported property type: ${l}`);W+=e[l]}const B=new DataView(l,n+11),i=new ArrayBuffer(Q.RowLength*R),h=U.FromEuler(new F(Math.PI/2,0,0));for(let F=0;F<R;F++){const l=new Float32Array(i,F*Q.RowLength,3),V=new Float32Array(i,F*Q.RowLength+12,3),Z=new Uint8ClampedArray(i,F*Q.RowLength+24,4),d=new Uint8ClampedArray(i,F*Q.RowLength+28,4);let n=255,R=0,e=0,s=0;a.forEach((U=>{let t;switch(U.type){case"float":t=B.getFloat32(U.offset+F*W,!0);break;case"int":t=B.getInt32(U.offset+F*W,!0);break;default:throw new Error(`Unsupported property type: ${U.type}`)}switch(U.name){case"x":l[0]=t;break;case"y":l[1]=t;break;case"z":l[2]=t;break;case"scale_0":V[0]=Math.exp(t);break;case"scale_1":V[1]=Math.exp(t);break;case"scale_2":V[2]=Math.exp(t);break;case"red":Z[0]=t;break;case"green":Z[1]=t;break;case"blue":Z[2]=t;break;case"f_dc_0":Z[0]=255*(.5+this.SH_C0*t);break;case"f_dc_1":Z[1]=255*(.5+this.SH_C0*t);break;case"f_dc_2":Z[2]=255*(.5+this.SH_C0*t);break;case"f_dc_3":Z[3]=255*(.5+this.SH_C0*t);break;case"opacity":Z[3]=1/(1+Math.exp(-t))*255;break;case"rot_0":n=t;break;case"rot_1":R=t;break;case"rot_2":e=t;break;case"rot_3":s=t}}));let c=new U(R,e,s,n);switch(t){case"polycam":{const F=l[1];l[1]=-l[2],l[2]=F,c=h.multiply(c);break}case"":break;default:throw new Error(`Unsupported format: ${t}`)}c=c.normalize(),d[0]=128*c.w+128,d[1]=128*c.x+128,d[2]=128*c.y+128,d[3]=128*c.z+128}return i}}function W(F,U,l){var t=void 0===U?null:U,V=function(F,U){var l=atob(F);if(U){for(var t=new Uint8Array(l.length),V=0,Z=l.length;V<Z;++V)t[V]=l.charCodeAt(V);return String.fromCharCode.apply(null,new Uint16Array(t.buffer))}return l}(F,void 0!==l&&l),Z=V.indexOf("\n",10)+1,d=V.substring(Z)+(t?"//# sourceMappingURL="+t:""),Q=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(Q)}R.SH_C0=.28209479177387814;var e,a,B,i,h=(e="Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsNCiAgICANCiAgICByZXR1cm4gKA0KICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgew0KDQogIHZhciBNb2R1bGU9bW9kdWxlQXJnO3ZhciByZWFkeVByb21pc2VSZXNvbHZlLHJlYWR5UHJvbWlzZVJlamVjdDtNb2R1bGVbInJlYWR5Il09bmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3JlYWR5UHJvbWlzZVJlc29sdmU9cmVzb2x2ZTtyZWFkeVByb21pc2VSZWplY3Q9cmVqZWN0O30pO3ZhciBtb2R1bGVPdmVycmlkZXM9T2JqZWN0LmFzc2lnbih7fSxNb2R1bGUpO3ZhciBzY3JpcHREaXJlY3Rvcnk9IiI7ZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKXtpZihNb2R1bGVbImxvY2F0ZUZpbGUiXSl7cmV0dXJuIE1vZHVsZVsibG9jYXRlRmlsZSJdKHBhdGgsc2NyaXB0RGlyZWN0b3J5KX1yZXR1cm4gc2NyaXB0RGlyZWN0b3J5K3BhdGh9dmFyIHJlYWRCaW5hcnk7e3tzY3JpcHREaXJlY3Rvcnk9c2VsZi5sb2NhdGlvbi5ocmVmO31pZihzY3JpcHREaXJlY3RvcnkuaW5kZXhPZigiYmxvYjoiKSE9PTApe3NjcmlwdERpcmVjdG9yeT1zY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sIiIpLmxhc3RJbmRleE9mKCIvIikrMSk7fWVsc2Uge3NjcmlwdERpcmVjdG9yeT0iIjt9e3tyZWFkQmluYXJ5PXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfTt9fX1Nb2R1bGVbInByaW50Il18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbInByaW50RXJyIl18fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKE1vZHVsZSxtb2R1bGVPdmVycmlkZXMpO21vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVsiYXJndW1lbnRzIl0pTW9kdWxlWyJhcmd1bWVudHMiXTtpZihNb2R1bGVbInRoaXNQcm9ncmFtIl0pTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdO2lmKE1vZHVsZVsicXVpdCJdKU1vZHVsZVsicXVpdCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVsid2FzbUJpbmFyeSJdKXdhc21CaW5hcnk9TW9kdWxlWyJ3YXNtQmluYXJ5Il07aWYodHlwZW9mIFdlYkFzc2VtYmx5IT0ib2JqZWN0Iil7YWJvcnQoIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKTt9dmFyIHdhc21NZW1vcnk7dmFyIEFCT1JUPWZhbHNlO3ZhciBIRUFQOCxIRUFQVTgsSEVBUDE2LEhFQVBVMTYsSEVBUDMyLEhFQVBVMzIsSEVBUEYzMixIRUFQRjY0O2Z1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCl7dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7TW9kdWxlWyJIRUFQOCJdPUhFQVA4PW5ldyBJbnQ4QXJyYXkoYik7TW9kdWxlWyJIRUFQMTYiXT1IRUFQMTY9bmV3IEludDE2QXJyYXkoYik7TW9kdWxlWyJIRUFQVTgiXT1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYik7TW9kdWxlWyJIRUFQVTE2Il09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYik7TW9kdWxlWyJIRUFQMzIiXT1IRUFQMzI9bmV3IEludDMyQXJyYXkoYik7TW9kdWxlWyJIRUFQVTMyIl09SEVBUFUzMj1uZXcgVWludDMyQXJyYXkoYik7TW9kdWxlWyJIRUFQRjMyIl09SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGIpO01vZHVsZVsiSEVBUEY2NCJdPUhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShiKTt9dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTtmdW5jdGlvbiBwcmVSdW4oKXtpZihNb2R1bGVbInByZVJ1biJdKXtpZih0eXBlb2YgTW9kdWxlWyJwcmVSdW4iXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZVJ1biJdPVtNb2R1bGVbInByZVJ1biJdXTt3aGlsZShNb2R1bGVbInByZVJ1biJdLmxlbmd0aCl7YWRkT25QcmVSdW4oTW9kdWxlWyJwcmVSdW4iXS5zaGlmdCgpKTt9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7fWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7fWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbInBvc3RSdW4iXSl7aWYodHlwZW9mIE1vZHVsZVsicG9zdFJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicG9zdFJ1biJdPVtNb2R1bGVbInBvc3RSdW4iXV07d2hpbGUoTW9kdWxlWyJwb3N0UnVuIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlWyJwb3N0UnVuIl0uc2hpZnQoKSk7fX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTt9ZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTt9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpO31mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2Ipe19fQVRQT1NUUlVOX18udW5zaGlmdChjYik7fXZhciBydW5EZXBlbmRlbmNpZXM9MDt2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7ZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0pe01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdKHJ1bkRlcGVuZGVuY2llcyk7fX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXSl7TW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0ocnVuRGVwZW5kZW5jaWVzKTt9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihkZXBlbmRlbmNpZXNGdWxmaWxsZWQpe3ZhciBjYWxsYmFjaz1kZXBlbmRlbmNpZXNGdWxmaWxsZWQ7ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7Y2FsbGJhY2soKTt9fX1mdW5jdGlvbiBhYm9ydCh3aGF0KXtpZihNb2R1bGVbIm9uQWJvcnQiXSl7TW9kdWxlWyJvbkFib3J0Il0od2hhdCk7fXdoYXQ9IkFib3J0ZWQoIit3aGF0KyIpIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTt3aGF0Kz0iLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLiI7dmFyIGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtyZWFkeVByb21pc2VSZWplY3QoZSk7dGhyb3cgZX12YXIgZGF0YVVSSVByZWZpeD0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7dmFyIGlzRGF0YVVSST1maWxlbmFtZT0+ZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTt2YXIgd2FzbUJpbmFyeUZpbGU7d2FzbUJpbmFyeUZpbGU9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBR0Z6YlFFQUFBQUJUZ3hnQkg5L2YzOEFZQU4vZjM4QVlBVi9mMzkvZndCZ0JuOS9mMzkvZndCZ0FYOEJmMkFBQUdBQ2YzOEFZQU4vZjM4QmYyQUJmd0JnQjM5L2YzOS9mMzhBWUFKL2Z3Ri9ZQVIvZjM1K0FBSTlDZ0ZoQVdFQUFRRmhBV0lBQWdGaEFXTUFBUUZoQVdRQUJnRmhBV1VBQVFGaEFXWUFDUUZoQVdjQUJBRmhBV2dBQmdGaEFXa0FBQUZoQVdvQUJnTVpHQWNFQ0FVSUNnVUxBUUFCQ0FRRkF3TUNBZ0FBQndjRUNRUUZBWEFCRUJBRkJ3RUJnQUtBZ0FJR0NBRi9BVUhnblFRTEJ4MEhBV3NDQUFGc0FBMEJiUUFoQVc0QUZ3RnZBUUFCY0FBV0FYRUFEZ2tWQVFCQkFRc1BFQ0FNRlJVZkRCNFlHaDBNR1JzY0NwOUhHSEVCQVg4Z0FrVUVRQ0FBS0FJRUlBRW9BZ1JHRHdzZ0FDQUJSZ1JBUVFFUEN3SkFJQUFvQWdRaUFpMEFBQ0lBUlNBQUlBRW9BZ1FpQVMwQUFDSURSM0lOQUFOQUlBRXRBQUVoQXlBQ0xRQUJJZ0JGRFFFZ0FVRUJhaUVCSUFKQkFXb2hBaUFBSUFOR0RRQUxDeUFBSUFOR0MwOEJBbjlCMkJrb0FnQWlBU0FBUVFkcVFYaHhJZ0pxSVFBQ1FDQUNRUUFnQUNBQlRSc05BQ0FBUHdCQkVIUkxCRUFnQUJBR1JRMEJDMEhZR1NBQU5nSUFJQUVQQzBIb0dVRXdOZ0lBUVg4TEJnQWdBQkFPQ3lrQVFlQVpRUUUyQWdCQjVCbEJBRFlDQUJBUVFlUVpRZHdaS0FJQU5nSUFRZHdaUWVBWk5nSUFDOUlMQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ0lnQUVFRWF5Z0NBQ0lCUVhoeElnQnFJUVVDUUNBQlFRRnhEUUFnQVVFRGNVVU5BU0FDSUFJb0FnQWlBV3NpQWtIOEdTZ0NBRWtOQVNBQUlBRnFJUUFDUUFKQVFZQWFLQUlBSUFKSEJFQWdBVUgvQVUwRVFDQUJRUU4ySVFRZ0FpZ0NEQ0lCSUFJb0FnZ2lBMFlFUUVIc0dVSHNHU2dDQUVGK0lBUjNjVFlDQUF3RkN5QURJQUUyQWd3Z0FTQUROZ0lJREFRTElBSW9BaGdoQmlBQ0lBSW9BZ3dpQVVjRVFDQUNLQUlJSWdNZ0FUWUNEQ0FCSUFNMkFnZ01Bd3NnQWtFVWFpSUVLQUlBSWdORkJFQWdBaWdDRUNJRFJRMENJQUpCRUdvaEJBc0RRQ0FFSVFjZ0F5SUJRUlJxSWdRb0FnQWlBdzBBSUFGQkVHb2hCQ0FCS0FJUUlnTU5BQXNnQjBFQU5nSUFEQUlMSUFVb0FnUWlBVUVEY1VFRFJ3MENRZlFaSUFBMkFnQWdCU0FCUVg1eE5nSUVJQUlnQUVFQmNqWUNCQ0FGSUFBMkFnQVBDMEVBSVFFTElBWkZEUUFDUUNBQ0tBSWNJZ05CQW5SQm5CeHFJZ1FvQWdBZ0FrWUVRQ0FFSUFFMkFnQWdBUTBCUWZBWlFmQVpLQUlBUVg0Z0EzZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdBa1liYWlBQk5nSUFJQUZGRFFFTElBRWdCallDR0NBQ0tBSVFJZ01FUUNBQklBTTJBaEFnQXlBQk5nSVlDeUFDS0FJVUlnTkZEUUFnQVNBRE5nSVVJQU1nQVRZQ0dBc2dBaUFGVHcwQUlBVW9BZ1FpQVVFQmNVVU5BQUpBQWtBQ1FBSkFJQUZCQW5GRkJFQkJoQm9vQWdBZ0JVWUVRRUdFR2lBQ05nSUFRZmdaUWZnWktBSUFJQUJxSWdBMkFnQWdBaUFBUVFGeU5nSUVJQUpCZ0Jvb0FnQkhEUVpCOUJsQkFEWUNBRUdBR2tFQU5nSUFEd3RCZ0Jvb0FnQWdCVVlFUUVHQUdpQUNOZ0lBUWZRWlFmUVpLQUlBSUFCcUlnQTJBZ0FnQWlBQVFRRnlOZ0lFSUFBZ0Ftb2dBRFlDQUE4TElBRkJlSEVnQUdvaEFDQUJRZjhCVFFSQUlBRkJBM1loQkNBRktBSU1JZ0VnQlNnQ0NDSURSZ1JBUWV3WlFld1pLQUlBUVg0Z0JIZHhOZ0lBREFVTElBTWdBVFlDRENBQklBTTJBZ2dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lCUndSQVFmd1pLQUlBR2lBRktBSUlJZ01nQVRZQ0RDQUJJQU0yQWdnTUF3c2dCVUVVYWlJRUtBSUFJZ05GQkVBZ0JTZ0NFQ0lEUlEwQ0lBVkJFR29oQkFzRFFDQUVJUWNnQXlJQlFSUnFJZ1FvQWdBaUF3MEFJQUZCRUdvaEJDQUJLQUlRSWdNTkFBc2dCMEVBTmdJQURBSUxJQVVnQVVGK2NUWUNCQ0FDSUFCQkFYSTJBZ1FnQUNBQ2FpQUFOZ0lBREFNTFFRQWhBUXNnQmtVTkFBSkFJQVVvQWh3aUEwRUNkRUdjSEdvaUJDZ0NBQ0FGUmdSQUlBUWdBVFlDQUNBQkRRRkI4QmxCOEJrb0FnQkJmaUFEZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBRlJodHFJQUUyQWdBZ0FVVU5BUXNnQVNBR05nSVlJQVVvQWhBaUF3UkFJQUVnQXpZQ0VDQURJQUUyQWhnTElBVW9BaFFpQTBVTkFDQUJJQU0yQWhRZ0F5QUJOZ0lZQ3lBQ0lBQkJBWEkyQWdRZ0FDQUNhaUFBTmdJQUlBSkJnQm9vQWdCSERRQkI5QmtnQURZQ0FBOExJQUJCL3dGTkJFQWdBRUY0Y1VHVUdtb2hBUUovUWV3WktBSUFJZ05CQVNBQVFRTjJkQ0lBY1VVRVFFSHNHU0FBSUFOeU5nSUFJQUVNQVFzZ0FTZ0NDQXNoQUNBQklBSTJBZ2dnQUNBQ05nSU1JQUlnQVRZQ0RDQUNJQUEyQWdnUEMwRWZJUU1nQUVILy8vOEhUUVJBSUFCQkppQUFRUWgyWnlJQmEzWkJBWEVnQVVFQmRHdEJQbW9oQXdzZ0FpQUROZ0ljSUFKQ0FEY0NFQ0FEUVFKMFFad2NhaUVCQWtBQ1FBSkFRZkFaS0FJQUlnUkJBU0FEZENJSGNVVUVRRUh3R1NBRUlBZHlOZ0lBSUFFZ0FqWUNBQ0FDSUFFMkFoZ01BUXNnQUVFWklBTkJBWFpyUVFBZ0EwRWZSeHQwSVFNZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQTBFZGRpRUJJQU5CQVhRaEF5QUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFJMkFoQWdBaUFFTmdJWUN5QUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBUW9BZ2dpQUNBQ05nSU1JQVFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUVOZ0lNSUFJZ0FEWUNDQXRCakJwQmpCb29BZ0JCQVdzaUFFRi9JQUFiTmdJQUN3c3BBUUYvSUFFRVFDQUFJUUlEUUNBQ1FRQTZBQUFnQWtFQmFpRUNJQUZCQVdzaUFRMEFDd3NnQUF2aEF3QkJqQmRCbWdrUUNVR1lGMEc1Q0VFQlFRQVFDRUdrRjBHMENFRUJRWUIvUWY4QUVBRkJ2QmRCclFoQkFVR0FmMEgvQUJBQlFiQVhRYXNJUVFGQkFFSC9BUkFCUWNnWFFZa0lRUUpCZ0lCK1FmLy9BUkFCUWRRWFFZQUlRUUpCQUVILy93TVFBVUhnRjBHWUNFRUVRWUNBZ0lCNFFmLy8vLzhIRUFGQjdCZEJqd2hCQkVFQVFYOFFBVUg0RjBIWENFRUVRWUNBZ0lCNFFmLy8vLzhIRUFGQmhCaEJ6Z2hCQkVFQVFYOFFBVUdRR0VHakNFS0FnSUNBZ0lDQWdJQi9Rdi8vLy8vLy8vLy8vd0FRRVVHY0dFR2lDRUlBUW44UUVVR29HRUdjQ0VFRUVBUkJ0QmhCa3dsQkNCQUVRWVFQUWVrSUVBTkJ6QTlCbHcwUUEwR1VFRUVFUWR3SUVBSkI0QkJCQWtIMUNCQUNRYXdSUVFSQmhBa1FBa0hJRVVHK0NCQUhRZkFSUVFCQjBnd1FBRUdZRWtFQVFiZ05FQUJCd0JKQkFVSHdEQkFBUWVnU1FRSkJud2tRQUVHUUUwRURRYjRKRUFCQnVCTkJCRUhtQ1JBQVFlQVRRUVZCZ3dvUUFFR0lGRUVFUWQwTkVBQkJzQlJCQlVIN0RSQUFRWmdTUVFCQjZRb1FBRUhBRWtFQlFjZ0tFQUJCNkJKQkFrR3JDeEFBUVpBVFFRTkJpUXNRQUVHNEUwRUVRYkVNRUFCQjRCTkJCVUdQREJBQVFkZ1VRUWhCN2dzUUFFR0FGVUVKUWN3TEVBQkJxQlZCQmtHcENoQUFRZEFWUVFkQm9nNFFBQXNjQUNBQUlBRkJDQ0FDcHlBQ1FpQ0lweUFEcHlBRFFpQ0lweEFGQ3lBQUFrQWdBQ2dDQkNBQlJ3MEFJQUFvQWh4QkFVWU5BQ0FBSUFJMkFod0xDNW9CQUNBQVFRRTZBRFVDUUNBQUtBSUVJQUpIRFFBZ0FFRUJPZ0EwQWtBZ0FDZ0NFQ0lDUlFSQUlBQkJBVFlDSkNBQUlBTTJBaGdnQUNBQk5nSVFJQU5CQVVjTkFpQUFLQUl3UVFGR0RRRU1BZ3NnQVNBQ1JnUkFJQUFvQWhnaUFrRUNSZ1JBSUFBZ0F6WUNHQ0FESVFJTElBQW9BakJCQVVjTkFpQUNRUUZHRFFFTUFnc2dBQ0FBS0FJa1FRRnFOZ0lrQ3lBQVFRRTZBRFlMQzEwQkFYOGdBQ2dDRUNJRFJRUkFJQUJCQVRZQ0pDQUFJQUkyQWhnZ0FDQUJOZ0lRRHdzQ1FDQUJJQU5HQkVBZ0FDZ0NHRUVDUncwQklBQWdBallDR0E4TElBQkJBVG9BTmlBQVFRSTJBaGdnQUNBQUtBSWtRUUZxTmdJa0N3c0NBQXU5SndFTWZ5TUFRUkJySWdva0FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBRUgwQVUwRVFFSHNHU2dDQUNJR1FSQWdBRUVMYWtGNGNTQUFRUXRKR3lJRlFRTjJJZ0IySWdGQkEzRUVRQUpBSUFGQmYzTkJBWEVnQUdvaUFrRURkQ0lCUVpRYWFpSUFJQUZCbkJwcUtBSUFJZ0VvQWdnaUJFWUVRRUhzR1NBR1FYNGdBbmR4TmdJQURBRUxJQVFnQURZQ0RDQUFJQVEyQWdnTElBRkJDR29oQUNBQklBSkJBM1FpQWtFRGNqWUNCQ0FCSUFKcUlnRWdBU2dDQkVFQmNqWUNCQXdQQ3lBRlFmUVpLQUlBSWdkTkRRRWdBUVJBQWtCQkFpQUFkQ0lDUVFBZ0FtdHlJQUVnQUhSeGFDSUJRUU4wSWdCQmxCcHFJZ0lnQUVHY0dtb29BZ0FpQUNnQ0NDSUVSZ1JBUWV3WklBWkJmaUFCZDNFaUJqWUNBQXdCQ3lBRUlBSTJBZ3dnQWlBRU5nSUlDeUFBSUFWQkEzSTJBZ1FnQUNBRmFpSUlJQUZCQTNRaUFTQUZheUlFUVFGeU5nSUVJQUFnQVdvZ0JEWUNBQ0FIQkVBZ0IwRjRjVUdVR21vaEFVR0FHaWdDQUNFQ0FuOGdCa0VCSUFkQkEzWjBJZ054UlFSQVFld1pJQU1nQm5JMkFnQWdBUXdCQ3lBQktBSUlDeUVESUFFZ0FqWUNDQ0FESUFJMkFnd2dBaUFCTmdJTUlBSWdBellDQ0FzZ0FFRUlhaUVBUVlBYUlBZzJBZ0JCOUJrZ0JEWUNBQXdQQzBId0dTZ0NBQ0lMUlEwQklBdG9RUUowUVp3Y2FpZ0NBQ0lDS0FJRVFYaHhJQVZySVFNZ0FpRUJBMEFDUUNBQktBSVFJZ0JGQkVBZ0FTZ0NGQ0lBUlEwQkN5QUFLQUlFUVhoeElBVnJJZ0VnQXlBQklBTkpJZ0ViSVFNZ0FDQUNJQUViSVFJZ0FDRUJEQUVMQ3lBQ0tBSVlJUWtnQWlBQ0tBSU1JZ1JIQkVCQi9Ca29BZ0FhSUFJb0FnZ2lBQ0FFTmdJTUlBUWdBRFlDQ0F3T0N5QUNRUlJxSWdFb0FnQWlBRVVFUUNBQ0tBSVFJZ0JGRFFNZ0FrRVFhaUVCQ3dOQUlBRWhDQ0FBSWdSQkZHb2lBU2dDQUNJQURRQWdCRUVRYWlFQklBUW9BaEFpQUEwQUN5QUlRUUEyQWdBTURRdEJmeUVGSUFCQnYzOUxEUUFnQUVFTGFpSUFRWGh4SVFWQjhCa29BZ0FpQ0VVTkFFRUFJQVZySVFNQ1FBSkFBa0FDZjBFQUlBVkJnQUpKRFFBYVFSOGdCVUgvLy84SFN3MEFHaUFGUVNZZ0FFRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFDeUlIUVFKMFFad2NhaWdDQUNJQlJRUkFRUUFoQUF3QkMwRUFJUUFnQlVFWklBZEJBWFpyUVFBZ0IwRWZSeHQwSVFJRFFBSkFJQUVvQWdSQmVIRWdCV3NpQmlBRFR3MEFJQUVoQkNBR0lnTU5BRUVBSVFNZ0FTRUFEQU1MSUFBZ0FTZ0NGQ0lHSUFZZ0FTQUNRUjEyUVFSeGFpZ0NFQ0lCUmhzZ0FDQUdHeUVBSUFKQkFYUWhBaUFCRFFBTEN5QUFJQVJ5UlFSQVFRQWhCRUVDSUFkMElnQkJBQ0FBYTNJZ0NIRWlBRVVOQXlBQWFFRUNkRUdjSEdvb0FnQWhBQXNnQUVVTkFRc0RRQ0FBS0FJRVFYaHhJQVZySWdJZ0Ewa2hBU0FDSUFNZ0FSc2hBeUFBSUFRZ0FSc2hCQ0FBS0FJUUlnRUVmeUFCQlNBQUtBSVVDeUlBRFFBTEN5QUVSUTBBSUFOQjlCa29BZ0FnQld0UERRQWdCQ2dDR0NFSElBUWdCQ2dDRENJQ1J3UkFRZndaS0FJQUdpQUVLQUlJSWdBZ0FqWUNEQ0FDSUFBMkFnZ01EQXNnQkVFVWFpSUJLQUlBSWdCRkJFQWdCQ2dDRUNJQVJRMERJQVJCRUdvaEFRc0RRQ0FCSVFZZ0FDSUNRUlJxSWdFb0FnQWlBQTBBSUFKQkVHb2hBU0FDS0FJUUlnQU5BQXNnQmtFQU5nSUFEQXNMSUFWQjlCa29BZ0FpQkUwRVFFR0FHaWdDQUNFQUFrQWdCQ0FGYXlJQlFSQlBCRUFnQUNBRmFpSUNJQUZCQVhJMkFnUWdBQ0FFYWlBQk5nSUFJQUFnQlVFRGNqWUNCQXdCQ3lBQUlBUkJBM0kyQWdRZ0FDQUVhaUlCSUFFb0FnUkJBWEkyQWdSQkFDRUNRUUFoQVF0QjlCa2dBVFlDQUVHQUdpQUNOZ0lBSUFCQkNHb2hBQXdOQ3lBRlFmZ1pLQUlBSWdKSkJFQkIrQmtnQWlBRmF5SUJOZ0lBUVlRYVFZUWFLQUlBSWdBZ0JXb2lBallDQUNBQ0lBRkJBWEkyQWdRZ0FDQUZRUU55TmdJRUlBQkJDR29oQUF3TkMwRUFJUUFnQlVFdmFpSURBbjlCeEIwb0FnQUVRRUhNSFNnQ0FBd0JDMEhRSFVKL053SUFRY2dkUW9DZ2dJQ0FnQVEzQWdCQnhCMGdDa0VNYWtGd2NVSFlxdFdxQlhNMkFnQkIyQjFCQURZQ0FFR29IVUVBTmdJQVFZQWdDeUlCYWlJR1FRQWdBV3NpQ0hFaUFTQUZUUTBNUWFRZEtBSUFJZ1FFUUVHY0hTZ0NBQ0lISUFGcUlna2dCMDBnQkNBSlNYSU5EUXNDUUVHb0hTMEFBRUVFY1VVRVFBSkFBa0FDUUFKQVFZUWFLQUlBSWdRRVFFR3NIU0VBQTBBZ0JDQUFLQUlBSWdkUEJFQWdCeUFBS0FJRWFpQUVTdzBEQ3lBQUtBSUlJZ0FOQUFzTFFRQVFDeUlDUVg5R0RRTWdBU0VHUWNnZEtBSUFJZ0JCQVdzaUJDQUNjUVJBSUFFZ0Ftc2dBaUFFYWtFQUlBQnJjV29oQmdzZ0JTQUdUdzBEUWFRZEtBSUFJZ0FFUUVHY0hTZ0NBQ0lFSUFacUlnZ2dCRTBnQUNBSVNYSU5CQXNnQmhBTElnQWdBa2NOQVF3RkN5QUdJQUpySUFoeElnWVFDeUlDSUFBb0FnQWdBQ2dDQkdwR0RRRWdBaUVBQ3lBQVFYOUdEUUVnQlVFd2FpQUdUUVJBSUFBaEFnd0VDMEhNSFNnQ0FDSUNJQU1nQm10cVFRQWdBbXR4SWdJUUMwRi9SZzBCSUFJZ0Jtb2hCaUFBSVFJTUF3c2dBa0YvUncwQ0MwR29IVUdvSFNnQ0FFRUVjallDQUFzZ0FSQUxJZ0pCZjBaQkFCQUxJZ0JCZjBaeUlBQWdBazF5RFFVZ0FDQUNheUlHSUFWQktHcE5EUVVMUVp3ZFFad2RLQUlBSUFacUlnQTJBZ0JCb0Iwb0FnQWdBRWtFUUVHZ0hTQUFOZ0lBQ3dKQVFZUWFLQUlBSWdNRVFFR3NIU0VBQTBBZ0FpQUFLQUlBSWdFZ0FDZ0NCQ0lFYWtZTkFpQUFLQUlJSWdBTkFBc01CQXRCL0Jrb0FnQWlBRUVBSUFBZ0FrMGJSUVJBUWZ3WklBSTJBZ0FMUVFBaEFFR3dIU0FHTmdJQVFhd2RJQUkyQWdCQmpCcEJmellDQUVHUUdrSEVIU2dDQURZQ0FFRzRIVUVBTmdJQUEwQWdBRUVEZENJQlFad2FhaUFCUVpRYWFpSUVOZ0lBSUFGQm9CcHFJQVEyQWdBZ0FFRUJhaUlBUVNCSERRQUxRZmdaSUFaQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdRMkFnQkJoQm9nQVNBQ2FpSUJOZ0lBSUFFZ0JFRUJjallDQkNBQUlBSnFRU2cyQWdSQmlCcEIxQjBvQWdBMkFnQU1CQXNnQWlBRFRTQUJJQU5MY2cwQ0lBQW9BZ3hCQ0hFTkFpQUFJQVFnQm1vMkFnUkJoQm9nQTBGNElBTnJRUWR4SWdCcUlnRTJBZ0JCK0JsQitCa29BZ0FnQm1vaUFpQUFheUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUNJQU5xUVNnMkFnUkJpQnBCMUIwb0FnQTJBZ0FNQXd0QkFDRUVEQW9MUVFBaEFnd0lDMEg4R1NnQ0FDQUNTd1JBUWZ3WklBSTJBZ0FMSUFJZ0Jtb2hBVUdzSFNFQUFrQUNRQUpBQTBBZ0FTQUFLQUlBUndSQUlBQW9BZ2dpQUEwQkRBSUxDeUFBTFFBTVFRaHhSUTBCQzBHc0hTRUFBMEFnQXlBQUtBSUFJZ0ZQQkVBZ0FTQUFLQUlFYWlJRUlBTkxEUU1MSUFBb0FnZ2hBQXdBQ3dBTElBQWdBallDQUNBQUlBQW9BZ1FnQm1vMkFnUWdBa0Y0SUFKclFRZHhhaUlISUFWQkEzSTJBZ1FnQVVGNElBRnJRUWR4YWlJR0lBVWdCMm9pQldzaEFDQURJQVpHQkVCQmhCb2dCVFlDQUVINEdVSDRHU2dDQUNBQWFpSUFOZ0lBSUFVZ0FFRUJjallDQkF3SUMwR0FHaWdDQUNBR1JnUkFRWUFhSUFVMkFnQkI5QmxCOUJrb0FnQWdBR29pQURZQ0FDQUZJQUJCQVhJMkFnUWdBQ0FGYWlBQU5nSUFEQWdMSUFZb0FnUWlBMEVEY1VFQlJ3MEdJQU5CZUhFaENTQURRZjhCVFFSQUlBWW9BZ3dpQVNBR0tBSUlJZ0pHQkVCQjdCbEI3QmtvQWdCQmZpQURRUU4yZDNFMkFnQU1Cd3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0dDeUFHS0FJWUlRZ2dCaUFHS0FJTUlnSkhCRUFnQmlnQ0NDSUJJQUkyQWd3Z0FpQUJOZ0lJREFVTElBWkJGR29pQVNnQ0FDSURSUVJBSUFZb0FoQWlBMFVOQkNBR1FSQnFJUUVMQTBBZ0FTRUVJQU1pQWtFVWFpSUJLQUlBSWdNTkFDQUNRUkJxSVFFZ0FpZ0NFQ0lERFFBTElBUkJBRFlDQUF3RUMwSDRHU0FHUVNocklnQkJlQ0FDYTBFSGNTSUJheUlJTmdJQVFZUWFJQUVnQW1vaUFUWUNBQ0FCSUFoQkFYSTJBZ1FnQUNBQ2FrRW9OZ0lFUVlnYVFkUWRLQUlBTmdJQUlBTWdCRUVuSUFSclFRZHhha0V2YXlJQUlBQWdBMEVRYWtrYklnRkJHellDQkNBQlFiUWRLUUlBTndJUUlBRkJyQjBwQWdBM0FnaEJ0QjBnQVVFSWFqWUNBRUd3SFNBR05nSUFRYXdkSUFJMkFnQkJ1QjFCQURZQ0FDQUJRUmhxSVFBRFFDQUFRUWMyQWdRZ0FFRUlhaUVNSUFCQkJHb2hBQ0FNSUFSSkRRQUxJQUVnQTBZTkFDQUJJQUVvQWdSQmZuRTJBZ1FnQXlBQklBTnJJZ0pCQVhJMkFnUWdBU0FDTmdJQUlBSkIvd0ZOQkVBZ0FrRjRjVUdVR21vaEFBSi9RZXdaS0FJQUlnRkJBU0FDUVFOMmRDSUNjVVVFUUVIc0dTQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBU0FBSUFNMkFnZ2dBU0FETmdJTUlBTWdBRFlDRENBRElBRTJBZ2dNQVF0Qkh5RUFJQUpCLy8vL0IwMEVRQ0FDUVNZZ0FrRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUUFMSUFNZ0FEWUNIQ0FEUWdBM0FoQWdBRUVDZEVHY0hHb2hBUUpBQWtCQjhCa29BZ0FpQkVFQklBQjBJZ1p4UlFSQVFmQVpJQVFnQm5JMkFnQWdBU0FETmdJQURBRUxJQUpCR1NBQVFRRjJhMEVBSUFCQkgwY2JkQ0VBSUFFb0FnQWhCQU5BSUFRaUFTZ0NCRUY0Y1NBQ1JnMENJQUJCSFhZaEJDQUFRUUYwSVFBZ0FTQUVRUVJ4YWlJR0tBSVFJZ1FOQUFzZ0JpQUROZ0lRQ3lBRElBRTJBaGdnQXlBRE5nSU1JQU1nQXpZQ0NBd0JDeUFCS0FJSUlnQWdBellDRENBQklBTTJBZ2dnQTBFQU5nSVlJQU1nQVRZQ0RDQURJQUEyQWdnTFFmZ1pLQUlBSWdBZ0JVME5BRUg0R1NBQUlBVnJJZ0UyQWdCQmhCcEJoQm9vQWdBaUFDQUZhaUlDTmdJQUlBSWdBVUVCY2pZQ0JDQUFJQVZCQTNJMkFnUWdBRUVJYWlFQURBZ0xRZWdaUVRBMkFnQkJBQ0VBREFjTFFRQWhBZ3NnQ0VVTkFBSkFJQVlvQWh3aUFVRUNkRUdjSEdvaUJDZ0NBQ0FHUmdSQUlBUWdBallDQUNBQ0RRRkI4QmxCOEJrb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBR1JodHFJQUkyQWdBZ0FrVU5BUXNnQWlBSU5nSVlJQVlvQWhBaUFRUkFJQUlnQVRZQ0VDQUJJQUkyQWhnTElBWW9BaFFpQVVVTkFDQUNJQUUyQWhRZ0FTQUNOZ0lZQ3lBQUlBbHFJUUFnQmlBSmFpSUdLQUlFSVFNTElBWWdBMEYrY1RZQ0JDQUZJQUJCQVhJMkFnUWdBQ0FGYWlBQU5nSUFJQUJCL3dGTkJFQWdBRUY0Y1VHVUdtb2hBUUovUWV3WktBSUFJZ0pCQVNBQVFRTjJkQ0lBY1VVRVFFSHNHU0FBSUFKeU5nSUFJQUVNQVFzZ0FTZ0NDQXNoQUNBQklBVTJBZ2dnQUNBRk5nSU1JQVVnQVRZQ0RDQUZJQUEyQWdnTUFRdEJIeUVESUFCQi8vLy9CMDBFUUNBQVFTWWdBRUVJZG1jaUFXdDJRUUZ4SUFGQkFYUnJRVDVxSVFNTElBVWdBellDSENBRlFnQTNBaEFnQTBFQ2RFR2NIR29oQVFKQUFrQkI4QmtvQWdBaUFrRUJJQU4wSWdSeFJRUkFRZkFaSUFJZ0JISTJBZ0FnQVNBRk5nSUFEQUVMSUFCQkdTQURRUUYyYTBFQUlBTkJIMGNiZENFRElBRW9BZ0FoQWdOQUlBSWlBU2dDQkVGNGNTQUFSZzBDSUFOQkhYWWhBaUFEUVFGMElRTWdBU0FDUVFSeGFpSUVLQUlRSWdJTkFBc2dCQ0FGTmdJUUN5QUZJQUUyQWhnZ0JTQUZOZ0lNSUFVZ0JUWUNDQXdCQ3lBQktBSUlJZ0FnQlRZQ0RDQUJJQVUyQWdnZ0JVRUFOZ0lZSUFVZ0FUWUNEQ0FGSUFBMkFnZ0xJQWRCQ0dvaEFBd0NDd0pBSUFkRkRRQUNRQ0FFS0FJY0lnQkJBblJCbkJ4cUlnRW9BZ0FnQkVZRVFDQUJJQUkyQWdBZ0FnMEJRZkFaSUFoQmZpQUFkM0VpQ0RZQ0FBd0NDeUFIUVJCQkZDQUhLQUlRSUFSR0cyb2dBallDQUNBQ1JRMEJDeUFDSUFjMkFoZ2dCQ2dDRUNJQUJFQWdBaUFBTmdJUUlBQWdBallDR0FzZ0JDZ0NGQ0lBUlEwQUlBSWdBRFlDRkNBQUlBSTJBaGdMQWtBZ0EwRVBUUVJBSUFRZ0F5QUZhaUlBUVFOeU5nSUVJQUFnQkdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFRZ0JVRURjallDQkNBRUlBVnFJZ0lnQTBFQmNqWUNCQ0FDSUFOcUlBTTJBZ0FnQTBIL0FVMEVRQ0FEUVhoeFFaUWFhaUVBQW45QjdCa29BZ0FpQVVFQklBTkJBM1owSWdOeFJRUkFRZXdaSUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBallDQ0NBQklBSTJBZ3dnQWlBQU5nSU1JQUlnQVRZQ0NBd0JDMEVmSVFBZ0EwSC8vLzhIVFFSQUlBTkJKaUFEUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBaUFBTmdJY0lBSkNBRGNDRUNBQVFRSjBRWndjYWlFQkFrQUNRQ0FJUVFFZ0FIUWlCbkZGQkVCQjhCa2dCaUFJY2pZQ0FDQUJJQUkyQWdBTUFRc2dBMEVaSUFCQkFYWnJRUUFnQUVFZlJ4dDBJUUFnQVNnQ0FDRUZBMEFnQlNJQktBSUVRWGh4SUFOR0RRSWdBRUVkZGlFR0lBQkJBWFFoQUNBQklBWkJCSEZxSWdZb0FoQWlCUTBBQ3lBR0lBSTJBaEFMSUFJZ0FUWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUVvQWdnaUFDQUNOZ0lNSUFFZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFCTmdJTUlBSWdBRFlDQ0FzZ0JFRUlhaUVBREFFTEFrQWdDVVVOQUFKQUlBSW9BaHdpQUVFQ2RFR2NIR29pQVNnQ0FDQUNSZ1JBSUFFZ0JEWUNBQ0FFRFFGQjhCa2dDMEYrSUFCM2NUWUNBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBSkdHMm9nQkRZQ0FDQUVSUTBCQ3lBRUlBazJBaGdnQWlnQ0VDSUFCRUFnQkNBQU5nSVFJQUFnQkRZQ0dBc2dBaWdDRkNJQVJRMEFJQVFnQURZQ0ZDQUFJQVEyQWhnTEFrQWdBMEVQVFFSQUlBSWdBeUFGYWlJQVFRTnlOZ0lFSUFBZ0Ftb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBSWdCVUVEY2pZQ0JDQUNJQVZxSWdRZ0EwRUJjallDQkNBRElBUnFJQU0yQWdBZ0J3UkFJQWRCZUhGQmxCcHFJUUJCZ0Jvb0FnQWhBUUovUVFFZ0IwRURkblFpQlNBR2NVVUVRRUhzR1NBRklBWnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEJpQUFJQUUyQWdnZ0JpQUJOZ0lNSUFFZ0FEWUNEQ0FCSUFZMkFnZ0xRWUFhSUFRMkFnQkI5QmtnQXpZQ0FBc2dBa0VJYWlFQUN5QUtRUkJxSkFBZ0FBc2pBUUYvUWR3WktBSUFJZ0FFUUFOQUlBQW9BZ0FSQlFBZ0FDZ0NCQ0lBRFFBTEN3c2FBQ0FBSUFFb0FnZ2dCUkFLQkVBZ0FTQUNJQU1nQkJBVEN3czNBQ0FBSUFFb0FnZ2dCUkFLQkVBZ0FTQUNJQU1nQkJBVER3c2dBQ2dDQ0NJQUlBRWdBaUFESUFRZ0JTQUFLQUlBS0FJVUVRTUFDNUVCQUNBQUlBRW9BZ2dnQkJBS0JFQWdBU0FDSUFNUUVnOExBa0FnQUNBQktBSUFJQVFRQ2tVTkFBSkFJQUlnQVNnQ0VFY0VRQ0FCS0FJVUlBSkhEUUVMSUFOQkFVY05BU0FCUVFFMkFpQVBDeUFCSUFJMkFoUWdBU0FETmdJZ0lBRWdBU2dDS0VFQmFqWUNLQUpBSUFFb0FpUkJBVWNOQUNBQktBSVlRUUpIRFFBZ0FVRUJPZ0EyQ3lBQlFRUTJBaXdMQy9JQkFDQUFJQUVvQWdnZ0JCQUtCRUFnQVNBQ0lBTVFFZzhMQWtBZ0FDQUJLQUlBSUFRUUNnUkFBa0FnQWlBQktBSVFSd1JBSUFFb0FoUWdBa2NOQVFzZ0EwRUJSdzBDSUFGQkFUWUNJQThMSUFFZ0F6WUNJQUpBSUFFb0FpeEJCRVlOQUNBQlFRQTdBVFFnQUNnQ0NDSUFJQUVnQWlBQ1FRRWdCQ0FBS0FJQUtBSVVFUU1BSUFFdEFEVUVRQ0FCUVFNMkFpd2dBUzBBTkVVTkFRd0RDeUFCUVFRMkFpd0xJQUVnQWpZQ0ZDQUJJQUVvQWloQkFXbzJBaWdnQVNnQ0pFRUJSdzBCSUFFb0FoaEJBa2NOQVNBQlFRRTZBRFlQQ3lBQUtBSUlJZ0FnQVNBQ0lBTWdCQ0FBS0FJQUtBSVlFUUlBQ3dzeEFDQUFJQUVvQWdoQkFCQUtCRUFnQVNBQ0lBTVFGQThMSUFBb0FnZ2lBQ0FCSUFJZ0F5QUFLQUlBS0FJY0VRQUFDeGdBSUFBZ0FTZ0NDRUVBRUFvRVFDQUJJQUlnQXhBVUN3dktBd0VGZnlNQVFVQnFJZ1FrQUFKL1FRRWdBQ0FCUVFBUUNnMEFHa0VBSUFGRkRRQWFJd0JCUUdvaUF5UUFJQUVvQWdBaUJVRUVheWdDQUNFR0lBVkJDR3NvQWdBaEJTQURRZ0EzQWlBZ0EwSUFOd0lvSUFOQ0FEY0NNQ0FEUWdBM0FEY2dBMElBTndJWUlBTkJBRFlDRkNBRFFmd1ZOZ0lRSUFNZ0FUWUNEQ0FEUWF3V05nSUlJQUVnQldvaEFVRUFJUVVDUUNBR1Fhd1dRUUFRQ2dSQUlBTkJBVFlDT0NBR0lBTkJDR29nQVNBQlFRRkJBQ0FHS0FJQUtBSVVFUU1BSUFGQkFDQURLQUlnUVFGR0d5RUZEQUVMSUFZZ0EwRUlhaUFCUVFGQkFDQUdLQUlBS0FJWUVRSUFBa0FDUUNBREtBSXNEZ0lBQVFJTElBTW9BaHhCQUNBREtBSW9RUUZHRzBFQUlBTW9BaVJCQVVZYlFRQWdBeWdDTUVFQlJoc2hCUXdCQ3lBREtBSWdRUUZIQkVBZ0F5Z0NNQTBCSUFNb0FpUkJBVWNOQVNBREtBSW9RUUZIRFFFTElBTW9BaGdoQlFzZ0EwRkFheVFBUVFBZ0JTSUJSUTBBR2lBRVFReHFRVFFRRHhvZ0JFRUJOZ0k0SUFSQmZ6WUNGQ0FFSUFBMkFoQWdCQ0FCTmdJSUlBRWdCRUVJYWlBQ0tBSUFRUUVnQVNnQ0FDZ0NIQkVBQUNBRUtBSWdJZ0JCQVVZRVFDQUNJQVFvQWhnMkFnQUxJQUJCQVVZTElRY2dCRUZBYXlRQUlBY0xDZ0FnQUNBQlFRQVFDZ3NFQUNBQUM2a0RBZ1IvQW4xQi8vLy8vd2NoQ1VHQWdJQ0FlQ0VLQTBBZ0FTQUlSZ1JBUVFBaEJ5QUdRWUNBRUJBUElRQkRBQUNBUnlBS0lBbHJzcFVoREFOQUlBRWdCMFlFUUVFQUlRY2dCVUVBTmdJQUlBQkJCR3NoQUVFQUlRbEJBU0VJQTBBZ0NFR0FnQVJHUlFSQUlBVWdDRUVDZENJQ2FpQUFJQUpxS0FJQUlBbHFJZ2syQWdBZ0NFRUJhaUVJREFFTEN3TkFJQUVnQjBaRkJFQWdCU0FESUFkQkFuUnFLQUlBUVFKMGFpSUFJQUFvQWdBaUFFRUJhallDQUNBRUlBQkJBblJxSUFjMkFnQWdCMEVCYWlFSERBRUxDd1VDZnlBTUlBTWdCMEVDZEdvaUFpZ0NBQ0FKYTdPVUlndERBQUNBVDEwZ0MwTUFBQUFBWUhFRVFDQUxxUXdCQzBFQUN5RUlJQUlnQ0RZQ0FDQUFJQWhCQW5ScUlnSWdBaWdDQUVFQmFqWUNBQ0FIUVFGcUlRY01BUXNMQlNBRElBaEJBblJxQW44Z0FDb0NDQ0FDSUFoQkRHeHFJZ2NxQWdDVUlBQXFBaGdnQnlvQ0JKU1NJQUFxQWlnZ0J5b0NDSlNTUXdBQWdFV1VJZ3VMUXdBQUFFOWRCRUFnQzZnTUFRdEJnSUNBZ0hnTElnYzJBZ0FnQ1NBSElBY2dDVW9iSVFrZ0NpQUhJQWNnQ2tnYklRb2dDRUVCYWlFSURBRUxDd3NMNXhFQ0FFR0FDQXZXRVhWdWMybG5ibVZrSUhOb2IzSjBBSFZ1YzJsbmJtVmtJR2x1ZEFCbWJHOWhkQUIxYVc1ME5qUmZkQUIxYm5OcFoyNWxaQ0JqYUdGeUFHSnZiMndBWlcxelkzSnBjSFJsYmpvNmRtRnNBSFZ1YzJsbmJtVmtJR3h2Ym1jQWMzUmtPanAzYzNSeWFXNW5BSE4wWkRvNmMzUnlhVzVuQUhOMFpEbzZkVEUyYzNSeWFXNW5BSE4wWkRvNmRUTXljM1J5YVc1bkFHUnZkV0pzWlFCMmIybGtBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BITm9iM0owUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYm5OcFoyNWxaQ0J6YUc5eWRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGFXNTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFibk5wWjI1bFpDQnBiblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR1pzYjJGMFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBPRjkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhwYm5RNFgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUXhObDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME5qUmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwTmpSZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXbHVkRE15WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWRETXlYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWdWMybG5ibVZrSUdOb1lYSStBSE4wWkRvNlltRnphV05mYzNSeWFXNW5QSFZ1YzJsbmJtVmtJR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhOcFoyNWxaQ0JqYUdGeVBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4c2IyNW5QZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFibk5wWjI1bFpDQnNiMjVuUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhrYjNWaWJHVStBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsalRsTmZNVEZqYUdGeVgzUnlZV2wwYzBsalJVVk9VMTg1WVd4c2IyTmhkRzl5U1dORlJVVkZBQUFBQUVRTUFBQkNCd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNXaE9VMTh4TVdOb1lYSmZkSEpoYVhSelNXaEZSVTVUWHpsaGJHeHZZMkYwYjNKSmFFVkZSVVVBQUVRTUFBQ01Cd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNYZE9VMTh4TVdOb1lYSmZkSEpoYVhSelNYZEZSVTVUWHpsaGJHeHZZMkYwYjNKSmQwVkZSVVVBQUVRTUFBRFVCd0FBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNVUnpUbE5mTVRGamFHRnlYM1J5WVdsMGMwbEVjMFZGVGxOZk9XRnNiRzlqWVhSdmNrbEVjMFZGUlVVQUFBQkVEQUFBSEFnQUFFNVRkRE5mWHpJeE1tSmhjMmxqWDNOMGNtbHVaMGxFYVU1VFh6RXhZMmhoY2w5MGNtRnBkSE5KUkdsRlJVNVRYemxoYkd4dlkyRjBiM0pKUkdsRlJVVkZBQUFBUkF3QUFHZ0lBQUJPTVRCbGJYTmpjbWx3ZEdWdU0zWmhiRVVBQUVRTUFBQzBDQUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWTBWRkFBQkVEQUFBMEFnQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXRkZSUUFBUkF3QUFQZ0lBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxvUlVVQUFFUU1BQUFnQ1FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmMwVkZBQUJFREFBQVNBa0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTWFJGUlFBQVJBd0FBSEFKQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBscFJVVUFBRVFNQUFDWUNRQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpha1ZGQUFCRURBQUF3QWtBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1d4RlJRQUFSQXdBQU9nSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHRSVVVBQUVRTUFBQVFDZ0FBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKZUVWRkFBQkVEQUFBT0FvQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NYbEZSUUFBUkF3QUFHQUtBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxtUlVVQUFFUU1BQUNJQ2dBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSlpFVkZBQUJFREFBQXNBb0FBRTR4TUY5ZlkzaDRZV0pwZGpFeE5sOWZjMmhwYlY5MGVYQmxYMmx1Wm05RkFBQUFBR3dNQUFEWUNnQUEwQXdBQUU0eE1GOWZZM2g0WVdKcGRqRXhOMTlmWTJ4aGMzTmZkSGx3WlY5cGJtWnZSUUFBQUd3TUFBQUlDd0FBL0FvQUFBQUFBQUI4Q3dBQUFnQUFBQU1BQUFBRUFBQUFCUUFBQUFZQUFBQk9NVEJmWDJONGVHRmlhWFl4TWpOZlgyWjFibVJoYldWdWRHRnNYM1I1Y0dWZmFXNW1iMFVBYkF3QUFGUUxBQUQ4Q2dBQWRnQUFBRUFMQUFDSUN3QUFZZ0FBQUVBTEFBQ1VDd0FBWXdBQUFFQUxBQUNnQ3dBQWFBQUFBRUFMQUFDc0N3QUFZUUFBQUVBTEFBQzRDd0FBY3dBQUFFQUxBQURFQ3dBQWRBQUFBRUFMQUFEUUN3QUFhUUFBQUVBTEFBRGNDd0FBYWdBQUFFQUxBQURvQ3dBQWJBQUFBRUFMQUFEMEN3QUFiUUFBQUVBTEFBQUFEQUFBZUFBQUFFQUxBQUFNREFBQWVRQUFBRUFMQUFBWURBQUFaZ0FBQUVBTEFBQWtEQUFBWkFBQUFFQUxBQUF3REFBQUFBQUFBQ3dMQUFBQ0FBQUFCd0FBQUFRQUFBQUZBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQUFBQUFDMERBQUFBZ0FBQUF3QUFBQUVBQUFBQlFBQUFBZ0FBQUFOQUFBQURnQUFBQThBQUFCT01UQmZYMk40ZUdGaWFYWXhNakJmWDNOcFgyTnNZWE56WDNSNWNHVmZhVzVtYjBVQUFBQUFiQXdBQUl3TUFBQXNDd0FBVTNRNWRIbHdaVjlwYm1adkFBQUFBRVFNQUFEQURBQkIyQmtMQStBT0FRPT0iO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTt9ZnVuY3Rpb24gZ2V0QmluYXJ5U3luYyhmaWxlKXtpZihmaWxlPT13YXNtQmluYXJ5RmlsZSYmd2FzbUJpbmFyeSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpfXZhciBiaW5hcnk9dHJ5UGFyc2VBc0RhdGFVUkkoZmlsZSk7aWYoYmluYXJ5KXtyZXR1cm4gYmluYXJ5fWlmKHJlYWRCaW5hcnkpe3JldHVybiByZWFkQmluYXJ5KGZpbGUpfXRocm93ICJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW1wb3J0cykpLnRoZW4oaW5zdGFuY2U9Pmluc3RhbmNlKS50aGVuKHJlY2VpdmVyLHJlYXNvbj0+e2VycihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtyZWFzb259YCk7YWJvcnQocmVhc29uKTt9KX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSxiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spe3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl9ZnVuY3Rpb24gY3JlYXRlV2FzbSgpe3ZhciBpbmZvPXsiYSI6d2FzbUltcG9ydHN9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3dhc21FeHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7d2FzbU1lbW9yeT13YXNtRXhwb3J0c1siayJdO3VwZGF0ZU1lbW9yeVZpZXdzKCk7YWRkT25Jbml0KHdhc21FeHBvcnRzWyJsIl0pO3JlbW92ZVJ1bkRlcGVuZGVuY3koKTtyZXR1cm4gd2FzbUV4cG9ydHN9YWRkUnVuRGVwZW5kZW5jeSgpO2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsiaW5zdGFuY2UiXSk7fWlmKE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0pe3RyeXtyZXR1cm4gTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7ZXJyKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO319aW5zdGFudGlhdGVBc3luYyh3YXNtQmluYXJ5LHdhc21CaW5hcnlGaWxlLGluZm8scmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7cmV0dXJuIHt9fXZhciBjYWxsUnVudGltZUNhbGxiYWNrcz1jYWxsYmFja3M9Pnt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe2NhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7fX07TW9kdWxlWyJub0V4aXRSdW50aW1lIl18fHRydWU7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludD0ocHJpbWl0aXZlVHlwZSxuYW1lLHNpemUsbWluUmFuZ2UsbWF4UmFuZ2UpPT57fTt2YXIgZW1iaW5kX2luaXRfY2hhckNvZGVzPSgpPT57dmFyIGNvZGVzPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgaT0wO2k8MjU2OysraSl7Y29kZXNbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKTt9ZW1iaW5kX2NoYXJDb2Rlcz1jb2Rlczt9O3ZhciBlbWJpbmRfY2hhckNvZGVzO3ZhciByZWFkTGF0aW4xU3RyaW5nPXB0cj0+e3ZhciByZXQ9IiI7dmFyIGM9cHRyO3doaWxlKEhFQVBVOFtjXSl7cmV0Kz1lbWJpbmRfY2hhckNvZGVzW0hFQVBVOFtjKytdXTt9cmV0dXJuIHJldH07dmFyIGF3YWl0aW5nRGVwZW5kZW5jaWVzPXt9O3ZhciByZWdpc3RlcmVkVHlwZXM9e307dmFyIEJpbmRpbmdFcnJvcjt2YXIgdGhyb3dCaW5kaW5nRXJyb3I9bWVzc2FnZT0+e3Rocm93IG5ldyBCaW5kaW5nRXJyb3IobWVzc2FnZSl9O2Z1bmN0aW9uIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zPXt9KXt2YXIgbmFtZT1yZWdpc3RlcmVkSW5zdGFuY2UubmFtZTtpZighcmF3VHlwZSl7dGhyb3dCaW5kaW5nRXJyb3IoYHR5cGUgIiR7bmFtZX0iIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXJgKTt9aWYocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXtpZihvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpe3JldHVybn1lbHNlIHt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7bmFtZX0nIHR3aWNlYCk7fX1yZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV09cmVnaXN0ZXJlZEluc3RhbmNlO2lmKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXt2YXIgY2FsbGJhY2tzPWF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2RlbGV0ZSBhd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtjYWxsYmFja3MuZm9yRWFjaChjYj0+Y2IoKSk7fX1mdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucz17fSl7aWYoISgiYXJnUGFja0FkdmFuY2UiaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcigicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZSIpfXJldHVybiBzaGFyZWRSZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucyl9dmFyIEdlbmVyaWNXaXJlVHlwZVNpemU9ODt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfYm9vbD0ocmF3VHlwZSxuYW1lLHRydWVWYWx1ZSxmYWxzZVZhbHVlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmZ1bmN0aW9uKHd0KXtyZXR1cm4gISF3dH0sInRvV2lyZVR5cGUiOmZ1bmN0aW9uKGRlc3RydWN0b3JzLG8pe3JldHVybiBvP3RydWVWYWx1ZTpmYWxzZVZhbHVlfSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUFU4W3BvaW50ZXJdKX0sZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O2Z1bmN0aW9uIGhhbmRsZUFsbG9jYXRvckluaXQoKXtPYmplY3QuYXNzaWduKEhhbmRsZUFsbG9jYXRvci5wcm90b3R5cGUse2dldChpZCl7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW2lkXX0saGFzKGlkKXtyZXR1cm4gdGhpcy5hbGxvY2F0ZWRbaWRdIT09dW5kZWZpbmVkfSxhbGxvY2F0ZShoYW5kbGUpe3ZhciBpZD10aGlzLmZyZWVsaXN0LnBvcCgpfHx0aGlzLmFsbG9jYXRlZC5sZW5ndGg7dGhpcy5hbGxvY2F0ZWRbaWRdPWhhbmRsZTtyZXR1cm4gaWR9LGZyZWUoaWQpe3RoaXMuYWxsb2NhdGVkW2lkXT11bmRlZmluZWQ7dGhpcy5mcmVlbGlzdC5wdXNoKGlkKTt9fSk7fWZ1bmN0aW9uIEhhbmRsZUFsbG9jYXRvcigpe3RoaXMuYWxsb2NhdGVkPVt1bmRlZmluZWRdO3RoaXMuZnJlZWxpc3Q9W107fXZhciBlbXZhbF9oYW5kbGVzPW5ldyBIYW5kbGVBbGxvY2F0b3I7dmFyIF9fZW12YWxfZGVjcmVmPWhhbmRsZT0+e2lmKGhhbmRsZT49ZW12YWxfaGFuZGxlcy5yZXNlcnZlZCYmMD09PS0tZW12YWxfaGFuZGxlcy5nZXQoaGFuZGxlKS5yZWZjb3VudCl7ZW12YWxfaGFuZGxlcy5mcmVlKGhhbmRsZSk7fX07dmFyIGNvdW50X2VtdmFsX2hhbmRsZXM9KCk9Pnt2YXIgY291bnQ9MDtmb3IodmFyIGk9ZW12YWxfaGFuZGxlcy5yZXNlcnZlZDtpPGVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLmxlbmd0aDsrK2kpe2lmKGVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkW2ldIT09dW5kZWZpbmVkKXsrK2NvdW50O319cmV0dXJuIGNvdW50fTt2YXIgaW5pdF9lbXZhbD0oKT0+e2VtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLnB1c2goe3ZhbHVlOnVuZGVmaW5lZH0se3ZhbHVlOm51bGx9LHt2YWx1ZTp0cnVlfSx7dmFsdWU6ZmFsc2V9KTtlbXZhbF9oYW5kbGVzLnJlc2VydmVkPWVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLmxlbmd0aDtNb2R1bGVbImNvdW50X2VtdmFsX2hhbmRsZXMiXT1jb3VudF9lbXZhbF9oYW5kbGVzO307dmFyIEVtdmFsPXt0b1ZhbHVlOmhhbmRsZT0+e2lmKCFoYW5kbGUpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSAiK2hhbmRsZSk7fXJldHVybiBlbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnZhbHVlfSx0b0hhbmRsZTp2YWx1ZT0+e3N3aXRjaCh2YWx1ZSl7Y2FzZSB1bmRlZmluZWQ6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UgdHJ1ZTpyZXR1cm4gMztjYXNlIGZhbHNlOnJldHVybiA0O2RlZmF1bHQ6e3JldHVybiBlbXZhbF9oYW5kbGVzLmFsbG9jYXRlKHtyZWZjb3VudDoxLHZhbHVlOnZhbHVlfSl9fX19O2Z1bmN0aW9uIHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQMzJbcG9pbnRlcj4+Ml0pfXZhciBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmhhbmRsZT0+e3ZhciBydj1FbXZhbC50b1ZhbHVlKGhhbmRsZSk7X19lbXZhbF9kZWNyZWYoaGFuZGxlKTtyZXR1cm4gcnZ9LCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT5FbXZhbC50b0hhbmRsZSh2YWx1ZSksImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O3ZhciBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyPShuYW1lLHdpZHRoKT0+e3N3aXRjaCh3aWR0aCl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEYzMltwb2ludGVyPj4yXSl9O2Nhc2UgODpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0PShyYXdUeXBlLG5hbWUsc2l6ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjp2YWx1ZT0+dmFsdWUsInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PnZhbHVlLCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQOFtwb2ludGVyPj4wXTpwb2ludGVyPT5IRUFQVThbcG9pbnRlcj4+MF07Y2FzZSAyOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDE2W3BvaW50ZXI+PjFdOnBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07Y2FzZSA0OnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDMyW3BvaW50ZXI+PjJdOnBvaW50ZXI9PkhFQVBVMzJbcG9pbnRlcj4+Ml07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTtpZihtaW5SYW5nZT09PTApe3ZhciBiaXRzaGlmdD0zMi04KnNpemU7ZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTw8Yml0c2hpZnQ+Pj5iaXRzaGlmdDt9dmFyIGlzVW5zaWduZWRUeXBlPW5hbWUuaW5jbHVkZXMoInVuc2lnbmVkIik7dmFyIGNoZWNrQXNzZXJ0aW9ucz0odmFsdWUsdG9UeXBlTmFtZSk9Pnt9O3ZhciB0b1dpcmVUeXBlO2lmKGlzVW5zaWduZWRUeXBlKXt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWU+Pj4wfTt9ZWxzZSB7dG9XaXJlVHlwZT1mdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7Y2hlY2tBc3NlcnRpb25zKHZhbHVlLHRoaXMubmFtZSk7cmV0dXJuIHZhbHVlfTt9cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpmcm9tV2lyZVR5cGUsInRvV2lyZVR5cGUiOnRvV2lyZVR5cGUsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6aW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSxtaW5SYW5nZSE9PTApLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXc9KHJhd1R5cGUsZGF0YVR5cGVJbmRleCxuYW1lKT0+e3ZhciB0eXBlTWFwcGluZz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldO3ZhciBUQT10eXBlTWFwcGluZ1tkYXRhVHlwZUluZGV4XTtmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSl7dmFyIHNpemU9SEVBUFUzMltoYW5kbGU+PjJdO3ZhciBkYXRhPUhFQVBVMzJbaGFuZGxlKzQ+PjJdO3JldHVybiBuZXcgVEEoSEVBUDguYnVmZmVyLGRhdGEsc2l6ZSl9bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZGVjb2RlTWVtb3J5VmlldywiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpkZWNvZGVNZW1vcnlWaWV3fSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczp0cnVlfSk7fTtmdW5jdGlvbiByZWFkUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUFUzMltwb2ludGVyPj4yXSl9dmFyIHN0cmluZ1RvVVRGOEFycmF5PShzdHIsaGVhcCxvdXRJZHgsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjM7fWlmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109dTt9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9ZWxzZSB7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yNDB8dT4+MTg7aGVhcFtvdXRJZHgrK109MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO319aGVhcFtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH07dmFyIHN0cmluZ1RvVVRGOD0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT5zdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpO3ZhciBsZW5ndGhCeXRlc1VURjg9c3RyPT57dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGM8PTEyNyl7bGVuKys7fWVsc2UgaWYoYzw9MjA0Nyl7bGVuKz0yO31lbHNlIGlmKGM+PTU1Mjk2JiZjPD01NzM0Myl7bGVuKz00OysraTt9ZWxzZSB7bGVuKz0zO319cmV0dXJuIGxlbn07dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dW5kZWZpbmVkO3ZhciBVVEY4QXJyYXlUb1N0cmluZz0oaGVhcE9yQXJyYXksaWR4LG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBlbmRQdHI9aWR4O3doaWxlKGhlYXBPckFycmF5W2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXBPckFycmF5LmJ1ZmZlciYmVVRGOERlY29kZXIpe3JldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LGVuZFB0cikpfXZhciBzdHI9IiI7d2hpbGUoaWR4PGVuZFB0cil7dmFyIHUwPWhlYXBPckFycmF5W2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mjt9ZWxzZSB7dTA9KHUwJjcpPDwxOHx1MTw8MTJ8dTI8PDZ8aGVhcE9yQXJyYXlbaWR4KytdJjYzO31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTt9ZWxzZSB7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fX1yZXR1cm4gc3RyfTt2YXIgVVRGOFRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT5wdHI/VVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LHB0cixtYXhCeXRlc1RvUmVhZCk6IiI7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmc9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIHN0ZFN0cmluZ0lzVVRGOD1uYW1lPT09InN0ZDo6c3RyaW5nIjtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiKHZhbHVlKXt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBwYXlsb2FkPXZhbHVlKzQ7dmFyIHN0cjtpZihzdGRTdHJpbmdJc1VURjgpe3ZhciBkZWNvZGVTdGFydFB0cj1wYXlsb2FkO2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj1wYXlsb2FkK2k7aWYoaT09bGVuZ3RofHxIRUFQVThbY3VycmVudEJ5dGVQdHJdPT0wKXt2YXIgbWF4UmVhZD1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1VVEY4VG9TdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZCk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudDt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApO3N0cis9c3RyaW5nU2VnbWVudDt9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrMTt9fX1lbHNlIHt2YXIgYT1uZXcgQXJyYXkobGVuZ3RoKTtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2FbaV09U3RyaW5nLmZyb21DaGFyQ29kZShIRUFQVThbcGF5bG9hZCtpXSk7fXN0cj1hLmpvaW4oIiIpO31fZnJlZSh2YWx1ZSk7cmV0dXJuIHN0cn0sInRvV2lyZVR5cGUiKGRlc3RydWN0b3JzLHZhbHVlKXtpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YWx1ZT1uZXcgVWludDhBcnJheSh2YWx1ZSk7fXZhciBsZW5ndGg7dmFyIHZhbHVlSXNPZlR5cGVTdHJpbmc9dHlwZW9mIHZhbHVlPT0ic3RyaW5nIjtpZighKHZhbHVlSXNPZlR5cGVTdHJpbmd8fHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheXx8dmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXt0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZyIpO31pZihzdGRTdHJpbmdJc1VURjgmJnZhbHVlSXNPZlR5cGVTdHJpbmcpe2xlbmd0aD1sZW5ndGhCeXRlc1VURjgodmFsdWUpO31lbHNlIHtsZW5ndGg9dmFsdWUubGVuZ3RoO312YXIgYmFzZT1fbWFsbG9jKDQrbGVuZ3RoKzEpO3ZhciBwdHI9YmFzZSs0O0hFQVBVMzJbYmFzZT4+Ml09bGVuZ3RoO2lmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7c3RyaW5nVG9VVEY4KHZhbHVlLHB0cixsZW5ndGgrMSk7fWVsc2Uge2lmKHZhbHVlSXNPZlR5cGVTdHJpbmcpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7dmFyIGNoYXJDb2RlPXZhbHVlLmNoYXJDb2RlQXQoaSk7aWYoY2hhckNvZGU+MjU1KXtfZnJlZShwdHIpO3Rocm93QmluZGluZ0Vycm9yKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKTt9SEVBUFU4W3B0citpXT1jaGFyQ29kZTt9fWVsc2Uge2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7SEVBUFU4W3B0citpXT12YWx1ZVtpXTt9fX1pZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUsYmFzZSk7fXJldHVybiBiYXNlfSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpyZWFkUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb24ocHRyKXtfZnJlZShwdHIpO319KTt9O3ZhciBVVEYxNkRlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik6dW5kZWZpbmVkO3ZhciBVVEYxNlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZFB0cj1wdHI7dmFyIGlkeD1lbmRQdHI+PjE7dmFyIG1heElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQvMjt3aGlsZSghKGlkeD49bWF4SWR4KSYmSEVBUFUxNltpZHhdKSsraWR4O2VuZFB0cj1pZHg8PDE7aWYoZW5kUHRyLXB0cj4zMiYmVVRGMTZEZWNvZGVyKXJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsZW5kUHRyKSk7dmFyIHN0cj0iIjtmb3IodmFyIGk9MDshKGk+PW1heEJ5dGVzVG9SZWFkLzIpOysraSl7dmFyIGNvZGVVbml0PUhFQVAxNltwdHIraSoyPj4xXTtpZihjb2RlVW5pdD09MClicmVhaztzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVVuaXQpO31yZXR1cm4gc3RyfTt2YXIgc3RyaW5nVG9VVEYxNj0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT57aWYobWF4Qnl0ZXNUb1dyaXRlPT09dW5kZWZpbmVkKXttYXhCeXRlc1RvV3JpdGU9MjE0NzQ4MzY0Nzt9aWYobWF4Qnl0ZXNUb1dyaXRlPDIpcmV0dXJuIDA7bWF4Qnl0ZXNUb1dyaXRlLT0yO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIG51bUNoYXJzVG9Xcml0ZT1tYXhCeXRlc1RvV3JpdGU8c3RyLmxlbmd0aCoyP21heEJ5dGVzVG9Xcml0ZS8yOnN0ci5sZW5ndGg7Zm9yKHZhciBpPTA7aTxudW1DaGFyc1RvV3JpdGU7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7SEVBUDE2W291dFB0cj4+MV09Y29kZVVuaXQ7b3V0UHRyKz0yO31IRUFQMTZbb3V0UHRyPj4xXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjE2PXN0cj0+c3RyLmxlbmd0aCoyO3ZhciBVVEYzMlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGk9MDt2YXIgc3RyPSIiO3doaWxlKCEoaT49bWF4Qnl0ZXNUb1JlYWQvNCkpe3ZhciB1dGYzMj1IRUFQMzJbcHRyK2kqND4+Ml07aWYodXRmMzI9PTApYnJlYWs7KytpO2lmKHV0ZjMyPj02NTUzNil7dmFyIGNoPXV0ZjMyLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7fX1yZXR1cm4gc3RyfTt2YXIgc3RyaW5nVG9VVEYzMj0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT57aWYobWF4Qnl0ZXNUb1dyaXRlPT09dW5kZWZpbmVkKXttYXhCeXRlc1RvV3JpdGU9MjE0NzQ4MzY0Nzt9aWYobWF4Qnl0ZXNUb1dyaXRlPDQpcmV0dXJuIDA7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgZW5kUHRyPXN0YXJ0UHRyK21heEJ5dGVzVG9Xcml0ZS00O2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtpZihjb2RlVW5pdD49NTUyOTYmJmNvZGVVbml0PD01NzM0Myl7dmFyIHRyYWlsU3Vycm9nYXRlPXN0ci5jaGFyQ29kZUF0KCsraSk7Y29kZVVuaXQ9NjU1MzYrKChjb2RlVW5pdCYxMDIzKTw8MTApfHRyYWlsU3Vycm9nYXRlJjEwMjM7fUhFQVAzMltvdXRQdHI+PjJdPWNvZGVVbml0O291dFB0cis9NDtpZihvdXRQdHIrND5lbmRQdHIpYnJlYWt9SEVBUDMyW291dFB0cj4+Ml09MDtyZXR1cm4gb3V0UHRyLXN0YXJ0UHRyfTt2YXIgbGVuZ3RoQnl0ZXNVVEYzMj1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO2lmKGNvZGVVbml0Pj01NTI5NiYmY29kZVVuaXQ8PTU3MzQzKSsraTtsZW4rPTQ7fXJldHVybiBsZW59O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZz0ocmF3VHlwZSxjaGFyU2l6ZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgZGVjb2RlU3RyaW5nLGVuY29kZVN0cmluZyxnZXRIZWFwLGxlbmd0aEJ5dGVzVVRGLHNoaWZ0O2lmKGNoYXJTaXplPT09Mil7ZGVjb2RlU3RyaW5nPVVURjE2VG9TdHJpbmc7ZW5jb2RlU3RyaW5nPXN0cmluZ1RvVVRGMTY7bGVuZ3RoQnl0ZXNVVEY9bGVuZ3RoQnl0ZXNVVEYxNjtnZXRIZWFwPSgpPT5IRUFQVTE2O3NoaWZ0PTE7fWVsc2UgaWYoY2hhclNpemU9PT00KXtkZWNvZGVTdHJpbmc9VVRGMzJUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYzMjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjMyO2dldEhlYXA9KCk9PkhFQVBVMzI7c2hpZnQ9Mjt9cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjp2YWx1ZT0+e3ZhciBsZW5ndGg9SEVBUFUzMlt2YWx1ZT4+Ml07dmFyIEhFQVA9Z2V0SGVhcCgpO3ZhciBzdHI7dmFyIGRlY29kZVN0YXJ0UHRyPXZhbHVlKzQ7Zm9yKHZhciBpPTA7aTw9bGVuZ3RoOysraSl7dmFyIGN1cnJlbnRCeXRlUHRyPXZhbHVlKzQraSpjaGFyU2l6ZTtpZihpPT1sZW5ndGh8fEhFQVBbY3VycmVudEJ5dGVQdHI+PnNoaWZ0XT09MCl7dmFyIG1heFJlYWRCeXRlcz1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1kZWNvZGVTdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZEJ5dGVzKTtpZihzdHI9PT11bmRlZmluZWQpe3N0cj1zdHJpbmdTZWdtZW50O31lbHNlIHtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCk7c3RyKz1zdHJpbmdTZWdtZW50O31kZWNvZGVTdGFydFB0cj1jdXJyZW50Qnl0ZVB0citjaGFyU2l6ZTt9fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLHZhbHVlKT0+e2lmKCEodHlwZW9mIHZhbHVlPT0ic3RyaW5nIikpe3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke25hbWV9YCk7fXZhciBsZW5ndGg9bGVuZ3RoQnl0ZXNVVEYodmFsdWUpO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCtjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aD4+c2hpZnQ7ZW5jb2RlU3RyaW5nKHZhbHVlLHB0cis0LGxlbmd0aCtjaGFyU2l6ZSk7aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLHB0cik7fXJldHVybiBwdHJ9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cik7fX0pO307dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse2lzVm9pZDp0cnVlLG5hbWU6bmFtZSwiYXJnUGFja0FkdmFuY2UiOjAsImZyb21XaXJlVHlwZSI6KCk9PnVuZGVmaW5lZCwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLG8pPT51bmRlZmluZWR9KTt9O3ZhciBnZXRIZWFwTWF4PSgpPT4yMTQ3NDgzNjQ4O3ZhciBncm93TWVtb3J5PXNpemU9Pnt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjt2YXIgcGFnZXM9KHNpemUtYi5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7d2FzbU1lbW9yeS5ncm93KHBhZ2VzKTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319O3ZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcD1yZXF1ZXN0ZWRTaXplPT57dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPj4+PTA7dmFyIG1heEhlYXBTaXplPWdldEhlYXBNYXgoKTtpZihyZXF1ZXN0ZWRTaXplPm1heEhlYXBTaXplKXtyZXR1cm4gZmFsc2V9dmFyIGFsaWduVXA9KHgsbXVsdGlwbGUpPT54KyhtdWx0aXBsZS14JW11bHRpcGxlKSVtdWx0aXBsZTtmb3IodmFyIGN1dERvd249MTtjdXREb3duPD00O2N1dERvd24qPTIpe3ZhciBvdmVyR3Jvd25IZWFwU2l6ZT1vbGRTaXplKigxKy4yL2N1dERvd24pO292ZXJHcm93bkhlYXBTaXplPU1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLHJlcXVlc3RlZFNpemUrMTAwNjYzMjk2KTt2YXIgbmV3U2l6ZT1NYXRoLm1pbihtYXhIZWFwU2l6ZSxhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsb3Zlckdyb3duSGVhcFNpemUpLDY1NTM2KSk7dmFyIHJlcGxhY2VtZW50PWdyb3dNZW1vcnkobmV3U2l6ZSk7aWYocmVwbGFjZW1lbnQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O2VtYmluZF9pbml0X2NoYXJDb2RlcygpO0JpbmRpbmdFcnJvcj1Nb2R1bGVbIkJpbmRpbmdFcnJvciJdPWNsYXNzIEJpbmRpbmdFcnJvciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG1lc3NhZ2Upe3N1cGVyKG1lc3NhZ2UpO3RoaXMubmFtZT0iQmluZGluZ0Vycm9yIjt9fTtNb2R1bGVbIkludGVybmFsRXJyb3IiXT1jbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPSJJbnRlcm5hbEVycm9yIjt9fTtoYW5kbGVBbGxvY2F0b3JJbml0KCk7aW5pdF9lbXZhbCgpO3ZhciB3YXNtSW1wb3J0cz17ZjpfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQsaTpfX2VtYmluZF9yZWdpc3Rlcl9ib29sLGg6X19lbWJpbmRfcmVnaXN0ZXJfZW12YWwsZTpfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdCxiOl9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIsYTpfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyxkOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcsYzpfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZyxqOl9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQsZzpfZW1zY3JpcHRlbl9yZXNpemVfaGVhcH07dmFyIHdhc21FeHBvcnRzPWNyZWF0ZVdhc20oKTtNb2R1bGVbIl9zb3J0Il09KGEwLGExLGEyLGEzLGE0LGE1LGE2KT0+KE1vZHVsZVsiX3NvcnQiXT13YXNtRXhwb3J0c1sibSJdKShhMCxhMSxhMixhMyxhNCxhNSxhNik7TW9kdWxlWyJfX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzIl09KCk9PihNb2R1bGVbIl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3MiXT13YXNtRXhwb3J0c1sibiJdKSgpO3ZhciBfbWFsbG9jPU1vZHVsZVsiX21hbGxvYyJdPWEwPT4oX21hbGxvYz1Nb2R1bGVbIl9tYWxsb2MiXT13YXNtRXhwb3J0c1sicCJdKShhMCk7dmFyIF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT1hMD0+KF9mcmVlPU1vZHVsZVsiX2ZyZWUiXT13YXNtRXhwb3J0c1sicSJdKShhMCk7ZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpe3ZhciBkZWNvZGVkPWF0b2Iocyk7dmFyIGJ5dGVzPW5ldyBVaW50OEFycmF5KGRlY29kZWQubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGRlY29kZWQubGVuZ3RoOysraSl7Ynl0ZXNbaV09ZGVjb2RlZC5jaGFyQ29kZUF0KGkpO31yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpe2lmKCFpc0RhdGFVUkkoZmlsZW5hbWUpKXtyZXR1cm59cmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpfXZhciBjYWxsZWRSdW47ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyO307ZnVuY3Rpb24gcnVuKCl7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1wcmVSdW4oKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWZ1bmN0aW9uIGRvUnVuKCl7aWYoY2FsbGVkUnVuKXJldHVybjtjYWxsZWRSdW49dHJ1ZTtNb2R1bGVbImNhbGxlZFJ1biJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSlNb2R1bGVbIm9uUnVudGltZUluaXRpYWxpemVkIl0oKTtwb3N0UnVuKCk7fWlmKE1vZHVsZVsic2V0U3RhdHVzIl0pe01vZHVsZVsic2V0U3RhdHVzIl0oIlJ1bm5pbmcuLi4iKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVsic2V0U3RhdHVzIl0oIiIpO30sMSk7ZG9SdW4oKTt9LDEpO31lbHNlIHtkb1J1bigpO319aWYoTW9kdWxlWyJwcmVJbml0Il0pe2lmKHR5cGVvZiBNb2R1bGVbInByZUluaXQiXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZUluaXQiXT1bTW9kdWxlWyJwcmVJbml0Il1dO3doaWxlKE1vZHVsZVsicHJlSW5pdCJdLmxlbmd0aD4wKXtNb2R1bGVbInByZUluaXQiXS5wb3AoKSgpO319cnVuKCk7DQoNCg0KICAgIHJldHVybiBtb2R1bGVBcmcucmVhZHkNCiAgfQ0KDQogICk7DQogIH0pKCk7CgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55CiAgbGV0IHdhc21Nb2R1bGU7CiAgYXN5bmMgZnVuY3Rpb24gaW5pdFdhc20oKSB7CiAgICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBsb2FkV2FzbSgpOwogIH0KICBsZXQgc2NlbmU7CiAgbGV0IHZpZXdQcm9qOwogIGxldCBzb3J0UnVubmluZyA9IGZhbHNlOwogIGxldCB2aWV3UHJvalB0cjsKICBsZXQgZkJ1ZmZlclB0cjsKICBsZXQgZGVwdGhCdWZmZXJQdHI7CiAgbGV0IGRlcHRoSW5kZXhQdHI7CiAgbGV0IHN0YXJ0c1B0cjsKICBsZXQgY291bnRzUHRyOwogIGNvbnN0IGluaXRTY2VuZSA9IGFzeW5jICgpID0+IHsKICAgICAgaWYgKCF3YXNtTW9kdWxlKQogICAgICAgICAgYXdhaXQgaW5pdFdhc20oKTsKICAgICAgZkJ1ZmZlclB0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhzY2VuZS5wb3NpdGlvbnMubGVuZ3RoICogc2NlbmUucG9zaXRpb25zLkJZVEVTX1BFUl9FTEVNRU5UKTsKICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldChzY2VuZS5wb3NpdGlvbnMsIGZCdWZmZXJQdHIgLyA0KTsKICAgICAgdmlld1Byb2pQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMTYgKiA0KTsKICAgICAgZGVwdGhCdWZmZXJQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2Moc2NlbmUudmVydGV4Q291bnQgKiA0KTsKICAgICAgZGVwdGhJbmRleFB0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhzY2VuZS52ZXJ0ZXhDb3VudCAqIDQpOwogICAgICBzdGFydHNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2Moc2NlbmUudmVydGV4Q291bnQgKiA0KTsKICAgICAgY291bnRzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKHNjZW5lLnZlcnRleENvdW50ICogNCk7CiAgfTsKICBjb25zdCBydW5Tb3J0ID0gKHZpZXdQcm9qKSA9PiB7CiAgICAgIGNvbnN0IHZpZXdQcm9qQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSh2aWV3UHJvai5idWZmZXIpOwogICAgICB3YXNtTW9kdWxlLkhFQVBGMzIuc2V0KHZpZXdQcm9qQnVmZmVyLCB2aWV3UHJvalB0ciAvIDQpOwogICAgICB3YXNtTW9kdWxlLl9zb3J0KHZpZXdQcm9qUHRyLCBzY2VuZS52ZXJ0ZXhDb3VudCwgZkJ1ZmZlclB0ciwgZGVwdGhCdWZmZXJQdHIsIGRlcHRoSW5kZXhQdHIsIHN0YXJ0c1B0ciwgY291bnRzUHRyKTsKICAgICAgY29uc3QgZGVwdGhJbmRleCA9IG5ldyBVaW50MzJBcnJheSh3YXNtTW9kdWxlLkhFQVBVMzIuYnVmZmVyLCBkZXB0aEluZGV4UHRyLCBzY2VuZS52ZXJ0ZXhDb3VudCk7CiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZURlcHRoSW5kZXggPSBuZXcgVWludDMyQXJyYXkoZGVwdGhJbmRleC5zbGljZSgpKTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGRlcHRoSW5kZXg6IHRyYW5zZmVyYWJsZURlcHRoSW5kZXggfSwgW3RyYW5zZmVyYWJsZURlcHRoSW5kZXguYnVmZmVyXSk7CiAgfTsKICBjb25zdCB0aHJvdHRsZWRTb3J0ID0gKCkgPT4gewogICAgICBpZiAoIXNvcnRSdW5uaW5nKSB7CiAgICAgICAgICBzb3J0UnVubmluZyA9IHRydWU7CiAgICAgICAgICBjb25zdCBsYXN0VmlldyA9IHZpZXdQcm9qOwogICAgICAgICAgcnVuU29ydChsYXN0Vmlldyk7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICBzb3J0UnVubmluZyA9IGZhbHNlOwogICAgICAgICAgICAgIGlmIChsYXN0VmlldyAhPT0gdmlld1Byb2opIHsKICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkU29ydCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0sIDApOwogICAgICB9CiAgfTsKICBzZWxmLm9ubWVzc2FnZSA9IChlKSA9PiB7CiAgICAgIGlmIChlLmRhdGEuc2NlbmUpIHsKICAgICAgICAgIHNjZW5lID0gZS5kYXRhLnNjZW5lOwogICAgICAgICAgaW5pdFNjZW5lKCk7CiAgICAgIH0KICAgICAgaWYgKCFzY2VuZSB8fCAhd2FzbU1vZHVsZSkKICAgICAgICAgIHJldHVybjsKICAgICAgaWYgKGUuZGF0YS52aWV3UHJvaikgewogICAgICAgICAgdmlld1Byb2ogPSBlLmRhdGEudmlld1Byb2o7CiAgICAgICAgICB0aHJvdHRsZWRTb3J0KCk7CiAgICAgIH0KICB9OwoKfSkoKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyLmpzLm1hcAoK",a=null,B=!1,function(F){return i=i||W(e,a,B),new Worker(i,F)});class s{constructor(F=1){let U,l,t,V=0,Z=!1;this.init=(F,d)=>{V=0,Z=!0,U=F,l=F.gl.getUniformLocation(d,"u_useDepthFade"),U.gl.uniform1i(l,1),t=F.gl.getUniformLocation(d,"u_depthFade"),U.gl.uniform1f(t,V)},this.render=()=>{Z&&(V=Math.min(V+.01*F,1),V>=1&&(Z=!1,U.gl.uniform1i(l,0)),U.gl.uniform1f(t,V))}}}class c{constructor(F=null,U=null){const l=F||document.createElement("canvas");F||(l.style.display="block",l.style.boxSizing="border-box",l.style.width="100%",l.style.height="100%",l.style.margin="0",l.style.padding="0",document.body.appendChild(l)),l.style.background="#000",this.domElement=l;const t=l.getContext("webgl2",{alpha:!1,depth:!1,stencil:!1,antialias:!1,xrCompatible:!0,premultipliedAlpha:!1});this.gl=t;const V=U||[];let Z,d,Q,n,R,W,e,a,B,i,c,m,b,J;U||V.push(new s);let o=!1;this.resize=()=>{const F=l.clientWidth,U=l.clientHeight;l.width===F&&l.height===U||this.setSize(F,U)},this.setSize=(F,U)=>{l.width=F,l.height=U,d&&(t.viewport(0,0,l.width,l.height),d.update(l.width,l.height),e=t.getUniformLocation(W,"projection"),t.uniformMatrix4fv(e,!1,d.projectionMatrix.buffer),a=t.getUniformLocation(W,"viewport"),t.uniform2fv(a,new Float32Array([l.width,l.height])))};const N=()=>{Q=new h;const F={positions:Z.positions,vertexCount:Z.vertexCount};Q.postMessage({scene:F}),t.viewport(0,0,l.width,l.height),n=t.createShader(t.VERTEX_SHADER),t.shaderSource(n,"#version 300 es\nprecision lowp float;\nprecision lowp int;\n\nuniform highp usampler2D u_texture;\nuniform mat4 projection, view;\nuniform vec2 focal;\nuniform vec2 viewport;\n\n//uniform bool u_useDepthFade;\n//uniform float u_depthFade;\n\nin vec2 position;\nin int index;\n\nout vec4 vColor;\nout vec2 vPosition;\n\nvoid main () {\n    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);\n    vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1);\n    vec4 pos2d = projection * cam;\n\n    float clip = 1.2 * pos2d.w;\n    if (pos2d.z < -pos2d.w || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n    }\n\n\n    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);\n    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);\n    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);\n\n    mat3 J = mat3(\n        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), \n        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), \n        0., 0., 0.\n    );\n\n    mat3 T = transpose(mat3(view)) * J;\n    mat3 cov2d = transpose(T) * Vrk * T;\n\n    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;\n    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));\n    float lambda1 = mid + radius, lambda2 = mid - radius;\n\n    if(lambda2 < 0.0) return;\n    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));\n    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\n    vColor = vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;\n    vPosition = position;\n\n    float scalingFactor = 1.0;\n\n//    if(u_useDepthFade) {\n//        float depthNorm = (pos2d.z / pos2d.w + 1.0) / 2.0;\n//        float near = 0.1; float far = 100.0;\n//        float normalizedDepth = (2.0 * near) / (far + near - depthNorm * (far - near));\n//        float start = max(normalizedDepth - 0.1, 0.0);\n//        float end = min(normalizedDepth + 0.1, 1.0);\n//        scalingFactor = clamp((u_depthFade - start) / (end - start), 0.0, 1.0);\n//    }\n\n    vec2 vCenter = vec2(pos2d) / pos2d.w;\n    gl_Position = vec4(\n        vCenter \n        + position.x * majorAxis * scalingFactor / viewport \n        + position.y * minorAxis * scalingFactor / viewport, 0.0, 1.0);\n\n}\n"),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)||console.error(t.getShaderInfoLog(n)),R=t.createShader(t.FRAGMENT_SHADER),t.shaderSource(R,"#version 300 es\nprecision lowp float;\n\nin vec4 vColor;\nin vec2 vPosition;\n\nout vec4 fragColor;\n\nvoid main () {\n    float A = -dot(vPosition, vPosition);\n    if (A < -4.0) discard;\n    float B = exp(A) * vColor.a;\n    fragColor = vec4(B * vColor.rgb, B);\n}\n"),t.compileShader(R),t.getShaderParameter(R,t.COMPILE_STATUS)||console.error(t.getShaderInfoLog(R)),W=t.createProgram(),t.attachShader(W,n),t.attachShader(W,R),t.linkProgram(W),t.useProgram(W),t.getProgramParameter(W,t.LINK_STATUS)||console.error(t.getProgramInfoLog(W)),t.disable(t.DEPTH_TEST),t.enable(t.BLEND),t.blendFuncSeparate(t.ONE_MINUS_DST_ALPHA,t.ONE,t.ONE_MINUS_DST_ALPHA,t.ONE),t.blendEquationSeparate(t.FUNC_ADD,t.FUNC_ADD),d.update(l.width,l.height),e=t.getUniformLocation(W,"projection"),t.uniformMatrix4fv(e,!1,d.projectionMatrix.buffer),a=t.getUniformLocation(W,"viewport"),t.uniform2fv(a,new Float32Array([l.width,l.height])),B=t.getUniformLocation(W,"focal"),t.uniform2fv(B,new Float32Array([d.fx,d.fy])),i=t.getUniformLocation(W,"view"),t.uniformMatrix4fv(i,!1,d.viewMatrix.buffer);const U=new Float32Array([-2,-2,2,-2,2,2,-2,2]);J=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,J),t.bufferData(t.ARRAY_BUFFER,U,t.STATIC_DRAW),m=t.getAttribLocation(W,"position"),t.enableVertexAttribArray(m),t.vertexAttribPointer(m,2,t.FLOAT,!1,0,0);const s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),c=t.getUniformLocation(W,"u_texture"),t.uniform1i(c,0);const N=t.createBuffer();b=t.getAttribLocation(W,"index"),t.enableVertexAttribArray(b),t.bindBuffer(t.ARRAY_BUFFER,N),t.vertexAttribIPointer(b,1,t.INT,0,0),t.vertexAttribDivisor(b,1),t.bindTexture(t.TEXTURE_2D,s),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texImage2D(t.TEXTURE_2D,0,t.RGBA32UI,Z.width,Z.height,0,t.RGBA_INTEGER,t.UNSIGNED_INT,Z.data),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,s);for(const F of V)F.init(this,W);Q.onmessage=F=>{if(F.data.depthIndex){const{depthIndex:U}=F.data;t.bindBuffer(t.ARRAY_BUFFER,N),t.bufferData(t.ARRAY_BUFFER,U,t.STATIC_DRAW)}},o=!0},X=()=>{o&&this.dispose(),N()};this.prepareRender=(F,U)=>{F===Z&&U===d||(o&&this.dispose(),d=U,F!==Z&&(Z&&Z.removeEventListener("change",X),Z=F,Z.addEventListener("change",X)),N()),d.update(l.width,l.height)},this.sendCameraToWorker=()=>{Q.postMessage({viewProj:d.viewProj})},this.clearRender=()=>{t.clear(t.COLOR_BUFFER_BIT)},this.render=(F,U)=>{Z.vertexCount>0&&(t.uniformMatrix4fv(e,!1,d.projectionMatrix.buffer),t.uniform2fv(a,new Float32Array([F,U])),t.uniform2fv(B,new Float32Array([d.fx,d.fy])),t.uniformMatrix4fv(i,!1,d.viewMatrix.buffer),t.drawArraysInstanced(t.TRIANGLE_FAN,0,4,Z.vertexCount))},this.dispose=()=>{Q.terminate(),t.deleteShader(n),t.deleteShader(R),t.deleteProgram(W),t.deleteBuffer(J),t.deleteBuffer(undefined),t.deleteBuffer(undefined),t.deleteBuffer(undefined),t.deleteBuffer(undefined),o=!1},this.resize()}}class m{constructor(l,t,Z=.5,d=.5,Q=5,n=!0,R=new F){this.minAngle=-90,this.maxAngle=90,this.minZoom=.1,this.maxZoom=30,this.orbitSpeed=1,this.panSpeed=1,this.zoomSpeed=1,this.dampening=.12,this.setCameraTarget=()=>{},this.attach=()=>{},this.detach=()=>{};let W=R.clone(),e=W.clone(),a=Z,B=d,i=Q,h=!1,s=!1,c=0,m=0,b=0;const J={};let o=null,N=!1;const X=()=>{if(!o||N)return;const U=o.rotation.toEuler();a=-U.y,B=-U.x;const l=o.position.x-i*Math.sin(a)*Math.cos(B),t=o.position.y+i*Math.sin(B),V=o.position.z+i*Math.cos(a)*Math.cos(B);e=new F(l,t,V)};this.attach=F=>{o&&this.detach(),o=F,o.addEventListener("change",X)},this.detach=()=>{o&&(o.removeEventListener("change",X),o=null)},this.attach(l),this.setCameraTarget=U=>{if(!o)return;const l=U.x-o.position.x,t=U.y-o.position.y,V=U.z-o.position.z;i=Math.sqrt(l*l+t*t+V*V),B=Math.atan2(t,Math.sqrt(l*l+V*V)),a=-Math.atan2(l,V),e=new F(U.x,U.y,U.z)};const r=()=>.1+.9*(i-this.minZoom)/(this.maxZoom-this.minZoom),y=F=>{J[F.code]=!0,"ArrowUp"===F.code&&(J.KeyW=!0),"ArrowDown"===F.code&&(J.KeyS=!0),"ArrowLeft"===F.code&&(J.KeyA=!0),"ArrowRight"===F.code&&(J.KeyD=!0)},G=F=>{J[F.code]=!1,"ArrowUp"===F.code&&(J.KeyW=!1),"ArrowDown"===F.code&&(J.KeyS=!1),"ArrowLeft"===F.code&&(J.KeyA=!1),"ArrowRight"===F.code&&(J.KeyD=!1)},p=F=>{C(F),h=!0,s=2===F.button,m=F.clientX,b=F.clientY,window.addEventListener("mouseup",S)},S=F=>{C(F),h=!1,s=!1,window.removeEventListener("mouseup",S)},k=U=>{if(C(U),!h||!o)return;const l=U.clientX-m,t=U.clientY-b;if(s){const U=r(),Z=-l*this.panSpeed*.01*U,d=-t*this.panSpeed*.01*U,Q=V.RotationFromQuaternion(o.rotation).buffer,n=new F(Q[0],Q[3],Q[6]),R=new F(Q[1],Q[4],Q[7]);e=e.add(n.multiply(Z)),e=e.add(R.multiply(d))}else a-=l*this.orbitSpeed*.003,B+=t*this.orbitSpeed*.003,B=Math.min(Math.max(B,this.minAngle*Math.PI/180),this.maxAngle*Math.PI/180);m=U.clientX,b=U.clientY},Y=F=>{C(F);const U=r();i+=F.deltaY*this.zoomSpeed*.025*U,i=Math.min(Math.max(i,this.minZoom),this.maxZoom)},T=F=>{if(C(F),1===F.touches.length)h=!0,s=!1,m=F.touches[0].clientX,b=F.touches[0].clientY,c=0;else if(2===F.touches.length){h=!0,s=!0,m=(F.touches[0].clientX+F.touches[1].clientX)/2,b=(F.touches[0].clientY+F.touches[1].clientY)/2;const U=F.touches[0].clientX-F.touches[1].clientX,l=F.touches[0].clientY-F.touches[1].clientY;c=Math.sqrt(U*U+l*l)}},u=F=>{C(F),h=!1,s=!1},I=U=>{if(C(U),h&&o)if(s){const l=r(),t=U.touches[0].clientX-U.touches[1].clientX,Z=U.touches[0].clientY-U.touches[1].clientY,d=Math.sqrt(t*t+Z*Z);i+=(c-d)*this.zoomSpeed*.1*l,i=Math.min(Math.max(i,this.minZoom),this.maxZoom),c=d;const Q=(U.touches[0].clientX+U.touches[1].clientX)/2,n=(U.touches[0].clientY+U.touches[1].clientY)/2,R=Q-m,W=n-b,a=V.RotationFromQuaternion(o.rotation).buffer,B=new F(a[0],a[3],a[6]),h=new F(a[1],a[4],a[7]);e=e.add(B.multiply(-R*this.panSpeed*.025*l)),e=e.add(h.multiply(-W*this.panSpeed*.025*l)),m=Q,b=n}else{const F=U.touches[0].clientX-m,l=U.touches[0].clientY-b;a-=F*this.orbitSpeed*.003,B+=l*this.orbitSpeed*.003,B=Math.min(Math.max(B,this.minAngle*Math.PI/180),this.maxAngle*Math.PI/180),m=U.touches[0].clientX,b=U.touches[0].clientY}},E=(F,U,l)=>(1-l)*F+l*U;this.update=()=>{if(!o)return;N=!0,Z=E(Z,a,this.dampening),d=E(d,B,this.dampening),Q=E(Q,i,this.dampening),W=W.lerp(e,this.dampening);const l=W.x+Q*Math.sin(Z)*Math.cos(d),t=W.y-Q*Math.sin(d),n=W.z-Q*Math.cos(Z)*Math.cos(d);o.position=new F(l,t,n);const R=W.subtract(o.position).normalize(),h=Math.asin(-R.y),s=Math.atan2(R.x,R.z);o.rotation=U.FromEuler(new F(h,s,0));const c=.025,m=.01,b=V.RotationFromQuaternion(o.rotation).buffer,X=new F(-b[2],-b[5],-b[8]),r=new F(b[0],b[3],b[6]);J.KeyS&&(e=e.add(X.multiply(c))),J.KeyW&&(e=e.subtract(X.multiply(c))),J.KeyA&&(e=e.subtract(r.multiply(c))),J.KeyD&&(e=e.add(r.multiply(c))),J.KeyE&&(a+=m),J.KeyQ&&(a-=m),J.KeyR&&(B+=m),J.KeyF&&(B-=m),N=!1};const C=F=>{F.preventDefault(),F.stopPropagation()};this.dispose=()=>{t.removeEventListener("dragenter",C),t.removeEventListener("dragover",C),t.removeEventListener("dragleave",C),t.removeEventListener("contextmenu",C),t.removeEventListener("mousedown",p),t.removeEventListener("mousemove",k),t.removeEventListener("wheel",Y),t.removeEventListener("touchstart",T),t.removeEventListener("touchend",u),t.removeEventListener("touchmove",I),n&&(window.removeEventListener("keydown",y),window.removeEventListener("keyup",G))},n&&(window.addEventListener("keydown",y),window.addEventListener("keyup",G)),t.addEventListener("dragenter",C),t.addEventListener("dragover",C),t.addEventListener("dragleave",C),t.addEventListener("contextmenu",C),t.addEventListener("mousedown",p),t.addEventListener("mousemove",k),t.addEventListener("wheel",Y),t.addEventListener("touchstart",T),t.addEventListener("touchend",u),t.addEventListener("touchmove",I),this.update()}}class b{init(F,U){}render(){}}export{d as Camera,s as FadeInPass,n as Loader,V as Matrix3,Z as Matrix4,m as OrbitControls,R as PLYLoader,U as Quaternion,Q as Scene,b as ShaderPass,F as Vector3,c as WebGLRenderer};
//# sourceMappingURL=index.js.map
